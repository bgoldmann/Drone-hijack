# simulator/mgmt/routes/exploits.py
import os
import subprocess
import uuid
import json
import threading
from pathlib import Path
from datetime import datetime
from flask import Blueprint, jsonify, request
from extensions import db
from models import ExploitExecutionLog
from . import bp

# Path to exploits directory
EXPLOITS_DIR = Path(__file__).parent.parent.parent / "exploits"

# Store running executions
running_executions = {}
execution_lock = threading.Lock()

def _fetch_execution_status(execution_id: str) -> dict | None:
    """Get execution status from database or memory."""
    execution = ExploitExecutionLog.query.filter_by(execution_id=execution_id).first()
    if execution:
        return {
            "execution_id": execution.execution_id,
            "scenario_id": execution.scenario_id,
            "user_id": execution.user_id,
            "status": execution.status,
            "started_at": execution.started_at.isoformat() if execution.started_at else None,
            "completed_at": execution.completed_at.isoformat() if execution.completed_at else None,
            "error_message": execution.error_message
        }
    return None

@bp.route("/exploits/list", methods=["GET"])
def list_exploits():
    """List all available exploit scripts"""
    exploits = []
    
    # Scan all exploit category directories
    category_dirs = ["recon", "injection", "dos", "exfiltration", "tampering", 
                     "mitm", "replay", "network", "firmware", "hardware", "infrastructure"]
    
    for category_dir in category_dirs:
        category_path = EXPLOITS_DIR / category_dir
        if category_path.exists():
            for script_file in category_path.glob("*.py"):
                # Skip __init__ and other non-exploit files
                if script_file.stem.startswith('__'):
                    continue
                
                exploits.append({
                    "id": f"{category_dir}/{script_file.stem}",
                    "name": script_file.stem.replace("_", " ").title(),
                    "category": category_dir,
                    "path": str(script_file.relative_to(EXPLOITS_DIR))
                })
    
    return jsonify({
        "exploits": exploits,
        "total": len(exploits)
    })

@bp.route("/exploits/execute/<scenario_id>", methods=["POST"])
def execute_exploit(scenario_id: str):
    """Execute an exploit script for a scenario"""
    data = request.json or {}
    user_id = data.get("user_id", "anonymous")
    script_path = data.get("script_path")
    script_args = data.get("args", [])
    
    # Generate execution ID
    execution_id = str(uuid.uuid4())
    
    # Create execution log
    execution = ExploitExecutionLog(
        execution_id=execution_id,
        scenario_id=scenario_id,
        user_id=user_id,
        status="pending"
    )
    db.session.add(execution)
    db.session.commit()
    
    # Determine script path
    if not script_path:
        # Try to find script based on scenario_id
        script_path = find_script_for_scenario(scenario_id)
    
    if not script_path or not Path(EXPLOITS_DIR / script_path).exists():
        execution.status = "failed"
        execution.error_message = f"Script not found: {script_path}"
        execution.completed_at = datetime.utcnow()
        db.session.commit()
        return jsonify({"error": "Script not found", "execution_id": execution_id}), 404
    
    # Start execution in background thread
    def run_exploit():
        execution.status = "running"
        execution.started_at = datetime.utcnow()
        db.session.commit()
        
        try:
            script_full_path = EXPLOITS_DIR / script_path
            cmd = ["python3", str(script_full_path)] + script_args
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                cwd=str(EXPLOITS_DIR)
            )
            
            stdout, stderr = process.communicate(timeout=300)
            
            execution.status = "completed" if process.returncode == 0 else "failed"
            execution.output = stdout
            if stderr:
                execution.error_message = stderr
            execution.completed_at = datetime.utcnow()
            
        except subprocess.TimeoutExpired:
            execution.status = "failed"
            execution.error_message = "Execution timed out"
            execution.completed_at = datetime.utcnow()
        except Exception as e:
            execution.status = "failed"
            execution.error_message = str(e)
            execution.completed_at = datetime.utcnow()
        finally:
            db.session.commit()
            with execution_lock:
                if execution_id in running_executions:
                    del running_executions[execution_id]
    
    thread = threading.Thread(target=run_exploit, daemon=True)
    thread.start()
    
    with execution_lock:
        running_executions[execution_id] = thread
    
    return jsonify({
        "execution_id": execution_id,
        "status": "running",
        "message": "Exploit execution started"
    })

@bp.route("/exploits/chain/<chain_id>", methods=["POST"])
def execute_chain(chain_id: str):
    """Execute an attack chain"""
    data = request.json or {}
    user_id = data.get("user_id", "anonymous")
    params = data.get("params", {})
    
    execution_id = str(uuid.uuid4())
    
    # Create execution log
    execution = ExploitExecutionLog(
        execution_id=execution_id,
        scenario_id=f"chain:{chain_id}",
        user_id=user_id,
        status="pending"
    )
    db.session.add(execution)
    db.session.commit()
    
    # Start chain execution
    def run_chain():
        execution.status = "running"
        execution.started_at = datetime.utcnow()
        db.session.commit()
        
        try:
            chain_executor_path = EXPLOITS_DIR / "chains" / "chain_executor.py"
            
            # Build command with parameters
            cmd = ["python3", str(chain_executor_path), chain_id]
            for key, value in params.items():
                cmd.append(f"{key}={value}")
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                cwd=str(EXPLOITS_DIR)
            )
            
            stdout, stderr = process.communicate(timeout=600)
            
            execution.status = "completed" if process.returncode == 0 else "failed"
            execution.output = stdout
            if stderr:
                execution.error_message = stderr
            execution.completed_at = datetime.utcnow()
            
        except subprocess.TimeoutExpired:
            execution.status = "failed"
            execution.error_message = "Chain execution timed out"
            execution.completed_at = datetime.utcnow()
        except Exception as e:
            execution.status = "failed"
            execution.error_message = str(e)
            execution.completed_at = datetime.utcnow()
        finally:
            db.session.commit()
            with execution_lock:
                if execution_id in running_executions:
                    del running_executions[execution_id]
    
    thread = threading.Thread(target=run_chain, daemon=True)
    thread.start()
    
    with execution_lock:
        running_executions[execution_id] = thread
    
    return jsonify({
        "execution_id": execution_id,
        "status": "running",
        "message": f"Attack chain '{chain_id}' execution started"
    })

@bp.route("/exploits/status/<execution_id>", methods=["GET"])
def get_execution_status(execution_id: str):
    """Get execution status"""
    status = _fetch_execution_status(execution_id)
    if not status:
        return jsonify({"error": "Execution not found"}), 404
    return jsonify(status)

@bp.route("/exploits/chains", methods=["GET"])
def list_chains():
    """List available attack chains"""
    chains_dir = EXPLOITS_DIR / "chains"
    chain_definitions = chains_dir / "chain_definitions.yaml"
    
    if not chain_definitions.exists():
        return jsonify({"chains": [], "total": 0})
    
    try:
        import yaml
        with chain_definitions.open() as f:
            chains_data = yaml.safe_load(f) or {}
        
        chains = []
        for chain_id, chain_def in chains_data.get("chains", {}).items():
            chains.append({
                "id": chain_id,
                "name": chain_def.get("name", chain_id),
                "description": chain_def.get("description", ""),
                "stages": len(chain_def.get("stages", []))
            })
        
        return jsonify({
            "chains": chains,
            "total": len(chains)
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@bp.route("/exploits/active", methods=["GET"])
def get_active_exploits():
    """Get currently running exploit executions"""
    active_executions = ExploitExecutionLog.query.filter_by(status="running").all()
    
    executions = []
    for execution in active_executions:
        executions.append({
            "execution_id": execution.execution_id,
            "scenario_id": execution.scenario_id,
            "user_id": execution.user_id,
            "started_at": execution.started_at.isoformat() if execution.started_at else None,
            "elapsed": (datetime.utcnow() - execution.started_at).total_seconds() if execution.started_at else 0
        })
    
    return jsonify({
        "active": executions,
        "count": len(executions)
    })

@bp.route("/exploits/timeline", methods=["GET"])
def get_attack_timeline():
    """Get attack execution timeline"""
    limit = request.args.get("limit", 50, type=int)
    
    executions = ExploitExecutionLog.query.order_by(
        ExploitExecutionLog.started_at.desc()
    ).limit(limit).all()
    
    timeline = []
    for execution in executions:
        timeline.append({
            "execution_id": execution.execution_id,
            "scenario_id": execution.scenario_id,
            "user_id": execution.user_id,
            "status": execution.status,
            "started_at": execution.started_at.isoformat() if execution.started_at else None,
            "completed_at": execution.completed_at.isoformat() if execution.completed_at else None,
            "duration": (execution.completed_at - execution.started_at).total_seconds() 
                       if execution.started_at and execution.completed_at else None
        })
    
    return jsonify({
        "timeline": timeline,
        "total": len(timeline)
    })

def find_script_for_scenario(scenario_id: str) -> str:
    """Find exploit script for a scenario ID"""
    # Map scenario IDs to script paths
    scenario_map = {
        # Reconnaissance
        "wifi-analysis-cracking": "recon/wifi_crack.py",
        "drone-discovery": "recon/drone_discovery.py",
        "packet-sniffing": "recon/packet_sniffing.py",
        "protocol-fingerprinting": "recon/protocol_fingerprinting.py",
        "gps-telemetry-analysis": "recon/gps_telemetry_tracking.py",
        
        # Injection
        "mavlink-command-injection": "injection/mavlink_inject.py",
        "waypoint-injection": "injection/waypoint_override.py",
        "parameter-manipulation": "injection/parameter_manipulation.py",
        "buffer-overflow-cve-2024-40427": "injection/buffer_overflow_cve_2024_40427.py",
        "expresslrs-uid-leakage": "injection/expresslrs_uid_leakage.py",
        "mission-race-condition": "injection/mission_race_condition.py",
        "return-to-home-override": "injection/return_to_home_override.py",
        "geofencing-attack": "injection/geofence_bypass.py",
        
        # DoS
        "wireless-deauthentication": "dos/wifi_deauth.py",
        "communication-link-flooding": "dos/communication_flooding.py",
        "flight-termination": "dos/flight_termination.py",
        
        # Exfiltration
        "flight-log-extraction": "exfiltration/flight_log_extraction.py",
        "mission-extraction": "exfiltration/mission_extraction.py",
        "parameter-extraction": "exfiltration/parameter_extraction.py",
        "camera-feed-eavesdropping": "exfiltration/camera_feed_eavesdropping.py",
        
        # Tampering
        "gps-spoofing": "tampering/gps_spoofing.py",
        "battery-spoofing": "tampering/battery_spoofing.py",
        "alttitude-spoofing": "tampering/attitude_spoofing.py",
        "sensor-data-injection": "tampering/sensor_data_injection.py",
        
        # Advanced
        "ground-control-station-hijacking": "mitm/mavlink_mitm.py",
        "command-replay": "replay/command_replay.py",
        "arp-spoofing": "network/arp_spoofing.py",
        
        # Firmware
        "firmware-modding": "firmware/firmware_extraction.py",
        "firmware-decompile": "firmware/firmware_analysis.py",
        
        # Hardware/BLE
        "holy-stone-ble-rce": "hardware/holy_stone_ble_rce_cve_2024_52876.py",
        
        # Infrastructure (2026)
        "wireless-network-exploit": "infrastructure/wireless_network_exploit.py",
        "data-interception": "infrastructure/data_interception.py",
        "physical-payload-delivery": "infrastructure/physical_payload_delivery.py",
        "multi-vector-infrastructure-attack": "infrastructure/multi_vector_attack.py",
        
        # Injection - New Scripts
        "camera-gimbal-takeover": "injection/gimbal_takeover.py",
        "flight-mode-injection": "injection/flight_mode_injection.py",
        "companion-computer-web-ui-login-brute-force": "injection/web_ui_brute_force.py",
        "companion-computer-exploitation": "injection/companion_computer_exploit.py",
        "ground-control-station-hijacking": "injection/gcs_spoofing.py",
        
        # Tampering - New Scripts
        "vfr-hud-spoofing": "tampering/vfr_hud_spoofing.py",
        "system-status-spoofing": "tampering/system_status_spoofing.py",
        "satellite-spoofing": "tampering/satellite_spoofing.py",
        "emergency-status-spoofing": "tampering/emergency_status_spoofing.py",
        "critical-error-spoofing": "tampering/critical_error_spoofing.py",
        
        # DoS - New Scripts
        "gps-offset-glitching": "dos/gps_offset_glitching.py",
        "denial-of-takeoff": "dos/denial_of_takeoff.py",
        "camera-feed-ros-topic-flooding": "dos/ros_topic_flooding.py",
        
        # Exfiltration - New Scripts
        "wifi-client-data-leak": "exfiltration/wifi_client_data_leak.py",
        "ftp-eavesdropping": "exfiltration/ftp_eavesdropping.py",
        
        # Recon - New Scripts
        "ground-control-station-discovery": "recon/gcs_discovery.py",
        "companion-computer-discovery": "recon/companion_computer_discovery.py",
        
        # CVE Exploits
        "use-after-free-cve-2025-9020": "injection/use_after_free_cve_2025_9020.py",
        "trajectory-overflow-cve-2025-5640": "injection/trajectory_overflow_cve_2025_5640.py",
        "flight-path-manipulation-cve-2024-29460": "injection/flight_path_manipulation_cve_2024_29460.py",
        "breach-return-point-rce-cve-2024-30799": "injection/breach_return_point_rce_cve_2024_30799.py",
        "buffer-overflow-cve-2024-38951": "injection/buffer_overflow_cve_2024_38951.py",
        "logger-overflow-cve-2024-38952": "injection/logger_overflow_cve_2024_38952.py",
    }
    
    return scenario_map.get(scenario_id)
