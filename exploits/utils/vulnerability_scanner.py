#!/usr/bin/env python3
"""
Automated Vulnerability Scanner
Scans drone for known vulnerabilities and generates security report
"""

import sys
import json
import time
from pathlib import Path
from pymavlink import mavutil
from typing import Dict, List, Any

class VulnerabilityScanner:
    def __init__(self, connection_string: str):
        """
        Initialize vulnerability scanner
        
        Args:
            connection_string: MAVLink connection string
        """
        self.connection_string = connection_string
        self.connection = None
        self.vulnerabilities = []
        self.system_info = {}
    
    def connect(self) -> bool:
        """Establish MAVLink connection"""
        try:
            self.connection = mavutil.mavlink_connection(self.connection_string)
            self.connection.wait_heartbeat(timeout=5)
            print("[+] Connected to vehicle")
            return True
        except Exception as e:
            print(f"[-] Failed to connect: {e}")
            return False
    
    def scan_system_info(self):
        """Scan system information"""
        print("[*] Scanning system information...")
        
        # Get heartbeat
        msg = self.connection.recv_match(type='HEARTBEAT', blocking=True, timeout=2)
        if msg:
            self.system_info = {
                'system_id': msg.get_srcSystem(),
                'component_id': msg.get_srcComponent(),
                'vehicle_type': msg.type,
                'autopilot': msg.autopilot,
                'base_mode': msg.base_mode,
                'custom_mode': msg.custom_mode,
                'system_status': msg.system_status,
                'mavlink_version': msg.mavlink_version
            }
            
            # Get autopilot version
            self.connection.mav.command_long_send(
                self.connection.target_system,
                self.connection.target_component,
                mavutil.mavlink.MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES,
                0, 1, 0, 0, 0, 0, 0, 0
            )
            
            time.sleep(1)
            version_msg = self.connection.recv_match(type='AUTOPILOT_VERSION', blocking=True, timeout=2)
            if version_msg:
                self.system_info['flight_sw_version'] = version_msg.flight_sw_version
                self.system_info['middleware_version'] = version_msg.middleware_version
                self.system_info['os_sw_version'] = version_msg.os_sw_version
    
    def check_mavlink_auth(self):
        """Check if MAVLink authentication is enabled"""
        print("[*] Checking MAVLink authentication...")
        
        # MAVLink 1.0 has no authentication
        if self.system_info.get('mavlink_version', 2) == 1:
            self.vulnerabilities.append({
                'id': 'CVE-2020-10282',
                'name': 'MAVLink Authentication Missing',
                'severity': 'CRITICAL',
                'cvss': 9.8,
                'description': 'MAVLink 1.0 has no authentication mechanism',
                'impact': 'Identity spoofing, unauthorized access, MITM attacks',
                'mitigation': 'Upgrade to MAVLink 2.0 with package signing enabled'
            })
            return True
        
        # For MAVLink 2.0, check if signing is enabled
        # This would require checking message signatures
        # Simplified check: assume not enabled if we can connect without auth
        self.vulnerabilities.append({
            'id': 'MAVLink-Auth-Optional',
            'name': 'MAVLink 2.0 Authentication Optional',
            'severity': 'HIGH',
            'description': 'MAVLink 2.0 authentication is optional and may not be enabled',
            'impact': 'Potential for unauthorized access',
            'mitigation': 'Enable MAVLink 2.0 package signing'
        })
        
        return True
    
    def check_geofence_vulnerability(self):
        """Check for geofence bypass vulnerability (CVE-2024-30800)"""
        print("[*] Checking geofence configuration...")
        
        # Request geofence parameters
        self.connection.mav.param_request_read_send(
            self.connection.target_system,
            self.connection.target_component,
            'FENCE_ENABLE'.encode('utf-8'),
            -1
        )
        
        time.sleep(0.5)
        msg = self.connection.recv_match(type='PARAM_VALUE', blocking=True, timeout=2)
        
        if msg:
            param_name = msg.param_id.rstrip('\x00')
            if param_name == 'FENCE_ENABLE':
                # Check if geofence can be modified without authentication
                self.vulnerabilities.append({
                    'id': 'CVE-2024-30800',
                    'name': 'Geofence Bypass Vulnerability',
                    'severity': 'HIGH',
                    'description': 'Geofence parameters can be modified without authentication',
                    'impact': 'Unauthorized flight in restricted areas',
                    'mitigation': 'Update to PX4-Autopilot v1.14.4 or later'
                })
                return True
        
        return False
    
    def check_buffer_overflow_vulnerability(self):
        """Check for buffer overflow vulnerabilities"""
        print("[*] Checking for buffer overflow vulnerabilities...")
        
        # Check autopilot type
        autopilot = self.system_info.get('autopilot')
        
        if autopilot == mavutil.mavlink.MAV_AUTOPILOT_PX4:
            # Check version (if available)
            version = self.system_info.get('flight_sw_version', 0)
            
            # CVE-2024-40427 affects PX4 v1.14.3 and earlier
            self.vulnerabilities.append({
                'id': 'CVE-2024-40427',
                'name': 'Stack Buffer Overflow in MAVLink Receiver',
                'severity': 'HIGH',
                'cvss': 7.9,
                'description': 'Stack buffer overflow in mavlink_receiver.cpp',
                'impact': 'Remote code execution, program crashes',
                'affected_versions': 'PX4-Autopilot v1.14.3 and earlier',
                'mitigation': 'Update to PX4-Autopilot v1.14.4 or later'
            })
        
        return True
    
    def check_encryption(self):
        """Check encryption status"""
        print("[*] Checking encryption...")
        
        # Check if messages are encrypted
        # In MAVLink, encryption is optional
        # Simplified: assume not encrypted if we can read messages
        
        self.vulnerabilities.append({
            'id': 'MAVLink-No-Encryption',
            'name': 'Unencrypted MAVLink Communication',
            'severity': 'HIGH',
            'description': 'MAVLink messages are transmitted in plaintext',
            'impact': 'All telemetry and commands are visible to attackers',
            'mitigation': 'Enable MAVLink 2.0 encryption'
        })
        
        return True
    
    def check_exposed_services(self):
        """Check for exposed services"""
        print("[*] Checking for exposed services...")
        
        # Common vulnerable services
        services = {
            'SSH': 22,
            'FTP': 21,
            'HTTP': 80,
            'HTTPS': 443,
            'MAVLink': 14550,
            'Companion Computer': 3000
        }
        
        # This would require network scanning
        # For now, add informational vulnerability
        self.vulnerabilities.append({
            'id': 'Exposed-Services',
            'name': 'Potentially Exposed Services',
            'severity': 'MEDIUM',
            'description': 'Various services may be exposed on companion computer',
            'impact': 'Unauthorized access to drone systems',
            'mitigation': 'Disable unnecessary services, use firewall rules'
        })
        
        return True
    
    def scan_all(self) -> Dict[str, Any]:
        """Run all vulnerability scans"""
        print("[*] Starting comprehensive vulnerability scan...")
        
        if not self.connect():
            return None
        
        # Scan system info
        self.scan_system_info()
        
        # Run vulnerability checks
        self.check_mavlink_auth()
        self.check_geofence_vulnerability()
        self.check_buffer_overflow_vulnerability()
        self.check_encryption()
        self.check_exposed_services()
        
        # Generate report
        report = {
            'system_info': self.system_info,
            'vulnerabilities': self.vulnerabilities,
            'summary': {
                'total': len(self.vulnerabilities),
                'critical': len([v for v in self.vulnerabilities if v.get('severity') == 'CRITICAL']),
                'high': len([v for v in self.vulnerabilities if v.get('severity') == 'HIGH']),
                'medium': len([v for v in self.vulnerabilities if v.get('severity') == 'MEDIUM']),
                'low': len([v for v in self.vulnerabilities if v.get('severity') == 'LOW'])
            }
        }
        
        return report
    
    def generate_report(self, report: Dict[str, Any], output_file: str = None):
        """Generate vulnerability report"""
        print("\n" + "=" * 60)
        print("Vulnerability Scan Report")
        print("=" * 60)
        
        print("\nSystem Information:")
        for key, value in report['system_info'].items():
            print(f"  {key}: {value}")
        
        print(f"\nVulnerabilities Found: {report['summary']['total']}")
        print(f"  Critical: {report['summary']['critical']}")
        print(f"  High: {report['summary']['high']}")
        print(f"  Medium: {report['summary']['medium']}")
        print(f"  Low: {report['summary']['low']}")
        
        print("\nDetailed Vulnerabilities:")
        for i, vuln in enumerate(report['vulnerabilities'], 1):
            print(f"\n{i}. {vuln['name']} ({vuln.get('id', 'N/A')})")
            print(f"   Severity: {vuln.get('severity', 'UNKNOWN')}")
            if 'cvss' in vuln:
                print(f"   CVSS Score: {vuln['cvss']}")
            print(f"   Description: {vuln['description']}")
            print(f"   Impact: {vuln.get('impact', 'N/A')}")
            print(f"   Mitigation: {vuln.get('mitigation', 'N/A')}")
        
        # Save to file
        if output_file:
            output_path = Path(output_file)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w') as f:
                json.dump(report, f, indent=2)
            print(f"\n[+] Report saved to {output_file}")
        
        print("=" * 60)

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 vulnerability_scanner.py <connection> [output_file]")
        print("Example: python3 vulnerability_scanner.py udp:127.0.0.1:14550")
        print("Example: python3 vulnerability_scanner.py udp:127.0.0.1:14550 report.json")
        sys.exit(1)
    
    connection_string = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else None
    
    scanner = VulnerabilityScanner(connection_string)
    report = scanner.scan_all()
    
    if report:
        scanner.generate_report(report, output_file)
    else:
        print("[-] Scan failed")
        sys.exit(1)

if __name__ == "__main__":
    main()
