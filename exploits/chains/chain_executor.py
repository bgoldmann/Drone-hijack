#!/usr/bin/env python3
"""
Multi-Stage Attack Chain Executor
Orchestrates complex multi-stage attack scenarios
"""

import sys
import yaml
import time
import subprocess
from pathlib import Path
from typing import List, Dict, Any, Optional

class ChainExecutor:
    def __init__(self, chain_definitions_path: str = None):
        """
        Initialize chain executor
        
        Args:
            chain_definitions_path: Path to chain_definitions.yaml
        """
        if chain_definitions_path is None:
            chain_definitions_path = Path(__file__).parent / "chain_definitions.yaml"
        
        self.chain_definitions_path = Path(chain_definitions_path)
        self.chains = self.load_chains()
    
    def load_chains(self) -> Dict[str, Any]:
        """Load attack chain definitions from YAML"""
        if not self.chain_definitions_path.exists():
            print(f"[-] Chain definitions file not found: {self.chain_definitions_path}")
            return {}
        
        with self.chain_definitions_path.open() as f:
            return yaml.safe_load(f) or {}
    
    def list_chains(self) -> List[str]:
        """List available attack chains"""
        return list(self.chains.keys())
    
    def get_chain(self, chain_id: str) -> Optional[Dict[str, Any]]:
        """Get chain definition by ID"""
        return self.chains.get(chain_id)
    
    def execute_chain(self, chain_id: str, params: Dict[str, Any] = None) -> bool:
        """
        Execute an attack chain
        
        Args:
            chain_id: Chain identifier
            params: Chain parameters (e.g., target IP, connection string)
        
        Returns:
            True if chain executed successfully
        """
        if params is None:
            params = {}
        
        chain = self.get_chain(chain_id)
        if not chain:
            print(f"[-] Chain '{chain_id}' not found")
            return False
        
        print(f"[*] Executing attack chain: {chain.get('name', chain_id)}")
        print(f"[*] Description: {chain.get('description', '')}")
        print()
        
        stages = chain.get('stages', [])
        if not stages:
            print("[-] Chain has no stages")
            return False
        
        results = []
        
        for i, stage in enumerate(stages, 1):
            stage_name = stage.get('name', f'Stage {i}')
            print(f"[*] [{i}/{len(stages)}] Executing: {stage_name}")
            
            success = self.execute_stage(stage, params, results)
            results.append({
                'stage': stage_name,
                'success': success
            })
            
            if not success:
                if stage.get('required', True):
                    print(f"[-] Required stage failed. Aborting chain.")
                    return False
                else:
                    print(f"[!] Optional stage failed. Continuing...")
            
            # Wait between stages if specified
            delay = stage.get('delay', 0)
            if delay > 0:
                print(f"[*] Waiting {delay} seconds before next stage...")
                time.sleep(delay)
        
        print()
        print("[+] Attack chain completed successfully")
        return True
    
    def execute_stage(self, stage: Dict[str, Any], params: Dict[str, Any], 
                      previous_results: List[Dict[str, Any]]) -> bool:
        """
        Execute a single stage
        
        Args:
            stage: Stage definition
            params: Chain parameters
            previous_results: Results from previous stages
        
        Returns:
            True if stage executed successfully
        """
        stage_type = stage.get('type')
        
        if stage_type == 'script':
            return self.execute_script_stage(stage, params, previous_results)
        elif stage_type == 'command':
            return self.execute_command_stage(stage, params, previous_results)
        elif stage_type == 'wait':
            return self.execute_wait_stage(stage, params, previous_results)
        elif stage_type == 'condition':
            return self.execute_condition_stage(stage, params, previous_results)
        else:
            print(f"[-] Unknown stage type: {stage_type}")
            return False
    
    def execute_script_stage(self, stage: Dict[str, Any], params: Dict[str, Any],
                             previous_results: List[Dict[str, Any]]) -> bool:
        """Execute a script-based stage"""
        script_path = stage.get('script')
        if not script_path:
            print("[-] No script path specified")
            return False
        
        script_path = Path(script_path)
        if not script_path.exists():
            # Try relative to exploits directory
            script_path = Path(__file__).parent.parent / script_path
            if not script_path.exists():
                print(f"[-] Script not found: {script_path}")
                return False
        
        if not script_path.is_file():
            print(f"[-] Path is not a file: {script_path}")
            return False
        
        script_args = stage.get('args', [])
        # Substitute parameters
        resolved_args = []
        for arg in script_args:
            if isinstance(arg, str):
                # Replace placeholders
                for key, value in params.items():
                    arg = arg.replace(f'${{{key}}}', str(value))
                resolved_args.append(arg)
            else:
                resolved_args.append(str(arg))
        
        # Validate resolved arguments (basic check)
        for arg in resolved_args:
            if len(str(arg)) > 1000:
                print(f"[!] Warning: Argument length exceeds 1000 characters")
        
        cmd = ['python3', str(script_path)] + resolved_args
        print(f"[*] Running: {' '.join(cmd)}")
        
        try:
            timeout = stage.get('timeout', 300)
            if timeout < 1:
                timeout = 300
            if timeout > 3600:
                print("[!] Warning: Stage timeout exceeds 1 hour")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
            if result.returncode == 0:
                print("[+] Stage completed successfully")
                if result.stdout:
                    print(result.stdout)
                return True
            else:
                print(f"[-] Stage failed with exit code {result.returncode}")
                if result.stderr:
                    print(result.stderr)
                return False
        except subprocess.TimeoutExpired:
            print("[-] Stage timed out")
            return False
        except Exception as e:
            print(f"[-] Error executing stage: {e}")
            return False
    
    def execute_command_stage(self, stage: Dict[str, Any], params: Dict[str, Any],
                              previous_results: List[Dict[str, Any]]) -> bool:
        """Execute a command-based stage"""
        command = stage.get('command')
        if not command:
            print("[-] No command specified")
            return False
        
        # Substitute parameters
        for key, value in params.items():
            command = command.replace(f'${{{key}}}', str(value))
        
        print(f"[*] Executing: {command}")
        
        try:
            timeout = stage.get('timeout', 60)
            if timeout < 1:
                timeout = 60
            if timeout > 3600:
                print("[!] Warning: Command timeout exceeds 1 hour")
            result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=timeout)
            if result.returncode == 0:
                print("[+] Command completed successfully")
                return True
            else:
                print(f"[-] Command failed")
                return False
        except subprocess.TimeoutExpired:
            print(f"[-] Command timed out after {timeout} seconds")
            return False
        except (OSError, PermissionError) as e:
            print(f"[-] Error executing command: {e}")
            return False
        except Exception as e:
            print(f"[-] Error executing command: {e}")
            return False
    
    def execute_wait_stage(self, stage: Dict[str, Any], params: Dict[str, Any],
                          previous_results: List[Dict[str, Any]]) -> bool:
        """Execute a wait stage"""
        try:
            duration = stage.get('duration', 5)
            if duration < 0:
                duration = 0
            if duration > 3600:
                print("[!] Warning: Wait duration exceeds 1 hour")
            print(f"[*] Waiting {duration} seconds...")
            time.sleep(duration)
            return True
        except (ValueError, TypeError) as e:
            print(f"[-] Invalid wait duration: {e}")
            return False
    
    def execute_condition_stage(self, stage: Dict[str, Any], params: Dict[str, Any],
                               previous_results: List[Dict[str, Any]]) -> bool:
        """Execute a conditional stage"""
        condition = stage.get('condition')
        if not condition:
            return True
        
        # Evaluate condition based on previous results
        # Simple implementation - check if previous stage succeeded
        if condition == 'previous_success':
            if previous_results:
                return previous_results[-1].get('success', False)
            return False
        
        return True

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 chain_executor.py <chain_id> [param=value ...]")
        print("\nAvailable chains:")
        executor = ChainExecutor()
        for chain_id in executor.list_chains():
            chain = executor.get_chain(chain_id)
            print(f"  - {chain_id}: {chain.get('name', 'Unnamed')}")
        sys.exit(1)
    
    chain_id = sys.argv[1]
    
    # Validate chain_id (basic check)
    if not chain_id or len(chain_id) > 100:
        print(f"[-] Invalid chain ID: {chain_id}")
        sys.exit(1)
    
    # Parse parameters
    params = {}
    for arg in sys.argv[2:]:
        if '=' in arg:
            key, value = arg.split('=', 1)
            # Basic validation
            if not key or len(key) > 100:
                print(f"[-] Invalid parameter key: {key}")
                continue
            if len(value) > 1000:
                print(f"[!] Warning: Parameter value for {key} exceeds 1000 characters")
            params[key] = value
    
    executor = ChainExecutor()
    success = executor.execute_chain(chain_id, params)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
