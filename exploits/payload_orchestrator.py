#!/usr/bin/env python3
"""
Payload Orchestrator - Comprehensive Severity-Based Payload Execution
Executes all 73+ payloads from all 11 attack categories, ordered by severity
"""

import sys
import os
import json
import time
import subprocess
import argparse
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple
from pymavlink import mavutil

# Add exploits directory to path
EXPLOITS_DIR = Path(__file__).parent
sys.path.insert(0, str(EXPLOITS_DIR))

# Import payload registry
from payload_registry import (
    PAYLOAD_REGISTRY,
    get_all_payloads,
    get_payloads_by_severity,
    get_payloads_by_category,
    get_payload_by_id,
    get_total_count,
    get_count_by_severity
)

# Import utilities
try:
    sys.path.insert(0, str(EXPLOITS_DIR / 'recon'))
    from drone_discovery import scan_network, identify_device
except ImportError:
    print("[!] Warning: drone_discovery not available")
    scan_network = None
    identify_device = None

try:
    sys.path.insert(0, str(EXPLOITS_DIR / 'utils'))
    from vulnerability_scanner import VulnerabilityScanner
except ImportError:
    print("[!] Warning: vulnerability_scanner not available")
    VulnerabilityScanner = None


class PayloadOrchestrator:
    """
    Comprehensive payload orchestrator that executes all payloads
    ordered by severity (CRITICAL → HIGH → MEDIUM → LOW)
    """
    
    def __init__(self, target: str, output_file: Optional[str] = None,
                 severity_filter: Optional[str] = None,
                 category_filter: Optional[str] = None,
                 timeout: int = 60,
                 retry: int = 0,
                 skip_recon: bool = False,
                 dry_run: bool = False,
                 verbose: bool = False):
        """
        Initialize payload orchestrator
        
        Args:
            target: Target connection string or network (e.g., 'udp:127.0.0.1:14550' or '10.13.0.0/24')
            output_file: Output JSON report file path
            severity_filter: Filter by severity (CRITICAL, HIGH, MEDIUM, LOW, ALL)
            category_filter: Filter by category (injection, tampering, dos, etc.)
            timeout: Timeout per payload in seconds (default: 60)
            retry: Number of retries for failed payloads (default: 0)
            skip_recon: Skip reconnaissance phase
            dry_run: Show what would be executed without running
            verbose: Verbose output
        """
        self.target = target
        self.output_file = output_file
        self.severity_filter = severity_filter.upper() if severity_filter else 'ALL'
        self.category_filter = category_filter.lower() if category_filter else None
        self.timeout = timeout
        self.retry = retry
        self.skip_recon = skip_recon
        self.dry_run = dry_run
        self.verbose = verbose
        
        self.target_info = {}
        self.discovered_targets = []
        self.execution_results = []
        self.start_time = None
        self.end_time = None
        
    def discover_target(self) -> bool:
        """
        Discover target drone characteristics
        """
        if self.skip_recon:
            print("[*] Skipping reconnaissance phase")
            # Try to connect directly
            if self.target.startswith('udp:') or self.target.startswith('tcp:'):
                self.target_info = {
                    'connection': self.target,
                    'autopilot': 'Unknown',
                    'firmware': 'Unknown'
                }
                return True
            return False
        
        print("="*70)
        print("PHASE 1: TARGET DISCOVERY")
        print("="*70)
        print()
        
        # If connection string provided, use it directly
        if self.target.startswith('udp:') or self.target.startswith('tcp:'):
            print(f"[*] Using provided connection: {self.target}")
            try:
                connection = mavutil.mavlink_connection(self.target)
                connection.wait_heartbeat(timeout=5)
                print("[+] Connected to target")
                
                # Get system info
                msg = connection.recv_match(type='HEARTBEAT', blocking=True, timeout=2)
                if msg:
                    autopilot_map = {
                        1: 'Generic',
                        3: 'ArduPilot',
                        4: 'PX4',
                        8: 'OpenPilot',
                        12: 'PX4'
                    }
                    autopilot = autopilot_map.get(msg.autopilot, 'Unknown')
                    
                    self.target_info = {
                        'connection': self.target,
                        'system_id': msg.get_srcSystem(),
                        'autopilot': autopilot,
                        'firmware': 'Unknown',
                        'mavlink_version': msg.mavlink_version
                    }
                    self.discovered_targets.append(self.target_info)
                    print(f"[+] Target identified: {autopilot}")
                    return True
            except Exception as e:
                print(f"[-] Failed to connect: {e}")
                return False
        
        # Otherwise, scan network
        if '/' in self.target or self.target.count('.') >= 2:
            print(f"[*] Scanning network: {self.target}")
            if scan_network is None:
                print("[-] Network scanning not available")
                return False
            
            try:
                network_base = self.target.split('/')[0].rsplit('.', 1)[0]
                discovered = scan_network(network_base)
                
                for ip, port in discovered:
                    print(f"[*] Identifying device at {ip}:{port}...")
                    if identify_device:
                        device_info = identify_device(ip, port)
                        if device_info:
                            self.discovered_targets.append({
                                'connection': f'udp:{ip}:{port}',
                                **device_info
                            })
                            print(f"[+] Identified: {device_info.get('type', 'Unknown')}")
                
                if not self.discovered_targets:
                    print("[-] No drones discovered on network")
                    return False
                
                # Use first discovered target
                self.target_info = self.discovered_targets[0]
                print(f"[+] Discovered {len(self.discovered_targets)} target(s)")
                return True
                
            except Exception as e:
                print(f"[-] Network scan failed: {e}")
                return False
        
        print("[-] Invalid target format")
        return False
    
    def filter_payloads(self) -> List[Dict[str, Any]]:
        """
        Filter payloads based on severity, category, and target compatibility
        """
        print()
        print("="*70)
        print("PHASE 2: PAYLOAD FILTERING")
        print("="*70)
        print()
        
        # Get all payloads
        if self.severity_filter == 'ALL':
            payloads = get_all_payloads()
        else:
            payloads = get_payloads_by_severity(self.severity_filter)
        
        # Filter by category
        if self.category_filter:
            payloads = [p for p in payloads if p['category'] == self.category_filter]
            print(f"[*] Filtering by category: {self.category_filter}")
        
        # Filter by target compatibility
        if self.target_info.get('autopilot'):
            autopilot = self.target_info['autopilot']
            compatible_payloads = []
            for payload in payloads:
                if 'Generic' in payload['targets'] or autopilot in payload['targets']:
                    compatible_payloads.append(payload)
                else:
                    if self.verbose:
                        print(f"[*] Skipping {payload['id']}: incompatible with {autopilot}")
            payloads = compatible_payloads
            print(f"[*] Filtered by target compatibility: {autopilot}")
        
        print(f"[+] Selected {len(payloads)} payloads for execution")
        return payloads
    
    def order_payloads(self, payloads: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Order payloads by severity and CVSS score
        """
        severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
        
        def sort_key(payload):
            # Get severity from registry
            for severity, payload_list in PAYLOAD_REGISTRY.items():
                if payload in payload_list:
                    return (severity_order.get(severity, 99), -payload.get('cvss', 0))
            return (99, 0)
        
        # Sort by severity, then by CVSS score (descending)
        ordered = sorted(payloads, key=sort_key)
        
        return ordered
    
    def execute_payload(self, payload: Dict[str, Any], connection: str) -> Dict[str, Any]:
        """
        Execute a single payload
        
        Args:
            payload: Payload dictionary from registry
            connection: Connection string to use
            
        Returns:
            Execution result dictionary
        """
        payload_id = payload['id']
        script_path = EXPLOITS_DIR / payload['script']
        
        result = {
            'id': payload_id,
            'name': payload['name'],
            'severity': self._get_payload_severity(payload),
            'category': payload['category'],
            'script': payload['script'],
            'status': 'PENDING',
            'execution_time': 0,
            'output': '',
            'error': None,
            'attempts': 0
        }
        
        # Check if script exists
        if not script_path.exists():
            result['status'] = 'SKIPPED'
            result['error'] = f"Script not found: {script_path}"
            return result
        
        # Build command
        cmd = ['python3', str(script_path)]
        
        # Build arguments based on payload args
        for arg in payload.get('args', []):
            if arg == 'connection':
                cmd.append(connection)
            elif arg == 'target_ip':
                # Extract IP from connection string
                if ':' in connection:
                    ip = connection.split(':')[1].split(':')[0]
                    cmd.append(ip)
                else:
                    cmd.append(connection)
            elif arg == 'target_url':
                # Use companion computer URL
                if '10.13.0.3' in connection:
                    cmd.append('http://10.13.0.3:3000')
                else:
                    cmd.append('http://localhost:3000')
            elif arg == 'interface':
                cmd.append('wlan0mon')  # Default interface
            elif arg == 'ssid':
                cmd.append('Drone_Wifi')  # Default SSID
            elif arg == 'mode':
                cmd.append('wep')  # Default mode
            elif arg == 'target_mac':
                cmd.append('02:00:00:00:01:00')  # Default MAC
            elif arg == 'lat':
                cmd.append('37.7749')  # Default coordinates
            elif arg == 'lon':
                cmd.append('-122.4194')
            elif arg == 'alt':
                cmd.append('100')
            elif arg == 'action':
                cmd.append('disable')  # Default action
            elif arg == 'command':
                cmd.append('SET_MODE')  # Default command
            elif arg == 'file':
                cmd.append(f'/tmp/{payload_id}.json')  # Default file
            elif arg == 'duration':
                cmd.append('300')  # Default duration
            elif arg == 'target_network':
                cmd.append(self.target)
            elif arg == 'target_location':
                cmd.append('37.7749,-122.4194,100')
            elif arg == 'device_address':
                cmd.append('00:11:22:33:44:55')  # Default BLE address
            elif arg == 'firmware_file':
                cmd.append('/tmp/firmware.bin')  # Default firmware file
            elif arg == 'network':
                cmd.append(self.target)
            elif arg == 'gateway_ip':
                cmd.append('10.13.0.1')  # Default gateway
            elif arg == 'rtsp_url':
                cmd.append('rtsp://10.13.0.3:8554/stream')  # Default RTSP URL
            else:
                # Unknown argument, skip
                if self.verbose:
                    print(f"[!] Unknown argument: {arg}")
        
        # Execute payload
        if self.dry_run:
            result['status'] = 'DRY_RUN'
            result['output'] = f"Would execute: {' '.join(cmd)}"
            return result
        
        start_time = time.time()
        attempts = 0
        max_attempts = 1 + self.retry
        
        while attempts < max_attempts:
            attempts += 1
            result['attempts'] = attempts
            
            try:
                if self.verbose:
                    print(f"[*] Executing: {' '.join(cmd)}")
                
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    cwd=str(EXPLOITS_DIR.parent)
                )
                
                try:
                    stdout, stderr = process.communicate(timeout=self.timeout)
                    execution_time = time.time() - start_time
                    
                    result['execution_time'] = execution_time
                    result['output'] = stdout.decode('utf-8', errors='ignore')
                    
                    if stderr:
                        result['error'] = stderr.decode('utf-8', errors='ignore')
                    
                    if process.returncode == 0:
                        result['status'] = 'SUCCESS'
                        break
                    else:
                        result['status'] = 'FAILED'
                        if attempts < max_attempts:
                            if self.verbose:
                                print(f"[*] Retrying {payload_id} (attempt {attempts + 1}/{max_attempts})")
                            time.sleep(2)  # Brief delay before retry
                        else:
                            break
                            
                except subprocess.TimeoutExpired:
                    process.kill()
                    result['status'] = 'TIMEOUT'
                    result['error'] = f"Execution exceeded timeout of {self.timeout} seconds"
                    break
                    
            except Exception as e:
                result['status'] = 'ERROR'
                result['error'] = str(e)
                break
        
        return result
    
    def _get_payload_severity(self, payload: Dict[str, Any]) -> str:
        """Get severity level for a payload"""
        for severity, payload_list in PAYLOAD_REGISTRY.items():
            if payload in payload_list:
                return severity
        return 'UNKNOWN'
    
    def execute_all_payloads(self, payloads: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Execute all payloads in order
        """
        print()
        print("="*70)
        print("PHASE 3: PAYLOAD EXECUTION")
        print("="*70)
        print()
        
        connection = self.target_info.get('connection', self.target)
        total = len(payloads)
        results = []
        
        # Group by severity for display
        severity_groups = {'CRITICAL': [], 'HIGH': [], 'MEDIUM': [], 'LOW': []}
        for payload in payloads:
            severity = self._get_payload_severity(payload)
            if severity in severity_groups:
                severity_groups[severity].append(payload)
        
        # Execute by severity
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            group_payloads = severity_groups[severity]
            if not group_payloads:
                continue
            
            print()
            print(f"[*] Executing {severity} severity payloads ({len(group_payloads)} payloads)...")
            print("-" * 70)
            
            for i, payload in enumerate(group_payloads, 1):
                # Calculate overall progress
                prev_severities = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']
                prev_index = prev_severities.index(severity)
                total_prev = sum(len(severity_groups[s]) for s in prev_severities[:prev_index])
                payload_num = total_prev + i
                total_payloads = sum(len(severity_groups[s]) for s in prev_severities)
                
                print(f"\n[{payload_num}/{total_payloads}] {payload['name']}")
                print(f"    ID: {payload['id']}")
                print(f"    Script: {payload['script']}")
                
                result = self.execute_payload(payload, connection)
                results.append(result)
                
                # Print result
                status_icon = {
                    'SUCCESS': '[+]',
                    'FAILED': '[-]',
                    'TIMEOUT': '[!]',
                    'ERROR': '[!]',
                    'SKIPPED': '[*]',
                    'DRY_RUN': '[~]'
                }.get(result['status'], '[?]')
                
                print(f"    {status_icon} Status: {result['status']}")
                if result['execution_time'] > 0:
                    print(f"    Time: {result['execution_time']:.2f}s")
                if result['error']:
                    print(f"    Error: {result['error'][:100]}")
        
        return results
    
    def generate_report(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Generate comprehensive JSON report
        """
        execution_time = (self.end_time - self.start_time) if self.end_time and self.start_time else 0
        
        # Count by status
        status_counts = {}
        for result in results:
            status = result['status']
            status_counts[status] = status_counts.get(status, 0) + 1
        
        # Count by severity
        by_severity = {}
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            severity_results = [r for r in results if r.get('severity') == severity]
            by_severity[severity] = {
                'total': len(severity_results),
                'executed': len([r for r in severity_results if r['status'] != 'SKIPPED']),
                'successful': len([r for r in severity_results if r['status'] == 'SUCCESS']),
                'failed': len([r for r in severity_results if r['status'] in ['FAILED', 'ERROR', 'TIMEOUT']])
            }
        
        report = {
            'timestamp': datetime.now().isoformat(),
            'target': self.target_info,
            'execution_summary': {
                'total_payloads': len(results),
                'executed': status_counts.get('SUCCESS', 0) + status_counts.get('FAILED', 0) + 
                           status_counts.get('ERROR', 0) + status_counts.get('TIMEOUT', 0),
                'skipped': status_counts.get('SKIPPED', 0),
                'successful': status_counts.get('SUCCESS', 0),
                'failed': status_counts.get('FAILED', 0) + status_counts.get('ERROR', 0) + 
                         status_counts.get('TIMEOUT', 0),
                'duration_seconds': execution_time
            },
            'by_severity': by_severity,
            'payloads': results
        }
        
        return report
    
    def run(self) -> bool:
        """
        Run the complete orchestration
        """
        print("="*70)
        print("PAYLOAD ORCHESTRATOR - COMPREHENSIVE ATTACK EXECUTION")
        print("="*70)
        print()
        print("⚠️  WARNING: This tool executes multiple attack payloads.")
        print("    Use only on systems you own or have explicit permission to test.")
        print()
        
        # Discover target
        if not self.discover_target():
            print("[-] Failed to discover target")
            return False
        
        # Filter payloads
        payloads = self.filter_payloads()
        if not payloads:
            print("[-] No payloads to execute")
            return False
        
        # Order payloads
        ordered_payloads = self.order_payloads(payloads)
        
        # Show execution plan
        print()
        print("="*70)
        print("EXECUTION PLAN")
        print("="*70)
        print(f"Total payloads: {len(ordered_payloads)}")
        counts = get_count_by_severity()
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            count = len([p for p in ordered_payloads if self._get_payload_severity(p) == severity])
            if count > 0:
                print(f"  {severity}: {count}")
        print()
        
        if self.dry_run:
            print("[~] DRY RUN MODE - No payloads will be executed")
            print()
            for payload in ordered_payloads[:10]:  # Show first 10
                print(f"  - {payload['name']} ({payload['id']})")
            if len(ordered_payloads) > 10:
                print(f"  ... and {len(ordered_payloads) - 10} more")
            return True
        
        # Execute payloads
        self.start_time = time.time()
        results = self.execute_all_payloads(ordered_payloads)
        self.end_time = time.time()
        
        # Generate report
        print()
        print("="*70)
        print("PHASE 4: REPORT GENERATION")
        print("="*70)
        print()
        
        report = self.generate_report(results)
        
        # Print summary
        print("EXECUTION SUMMARY")
        print("-" * 70)
        print(f"Total payloads: {report['execution_summary']['total_payloads']}")
        print(f"Executed: {report['execution_summary']['executed']}")
        print(f"Successful: {report['execution_summary']['successful']}")
        print(f"Failed: {report['execution_summary']['failed']}")
        print(f"Skipped: {report['execution_summary']['skipped']}")
        print(f"Duration: {report['execution_summary']['duration_seconds']:.2f} seconds")
        print()
        
        print("BY SEVERITY")
        print("-" * 70)
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            stats = report['by_severity'].get(severity, {})
            if stats.get('total', 0) > 0:
                print(f"{severity}: {stats.get('successful', 0)}/{stats.get('executed', 0)} successful "
                      f"(total: {stats.get('total', 0)})")
        
        # Save report
        if self.output_file:
            try:
                with open(self.output_file, 'w') as f:
                    json.dump(report, f, indent=2)
                print()
                print(f"[+] Report saved to: {self.output_file}")
            except Exception as e:
                print(f"[-] Failed to save report: {e}")
        
        return True


def main():
    parser = argparse.ArgumentParser(
        description='Payload Orchestrator - Execute all payloads ordered by severity',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Execute all payloads against local drone
  python3 payload_orchestrator.py udp:127.0.0.1:14550

  # Execute only HIGH severity payloads
  python3 payload_orchestrator.py udp:127.0.0.1:14550 --severity HIGH

  # Execute only injection payloads
  python3 payload_orchestrator.py udp:127.0.0.1:14550 --category injection

  # Dry run to see what would be executed
  python3 payload_orchestrator.py udp:127.0.0.1:14550 --dry-run

  # Save report to file
  python3 payload_orchestrator.py udp:127.0.0.1:14550 --output report.json
        """
    )
    
    parser.add_argument('target', help='Target connection string (e.g., udp:127.0.0.1:14550) or network (e.g., 10.13.0.0/24)')
    parser.add_argument('-o', '--output', help='Output JSON report file')
    parser.add_argument('-s', '--severity', choices=['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'ALL'], 
                       default='ALL', help='Filter by severity (default: ALL)')
    parser.add_argument('-c', '--category', help='Filter by category (injection, tampering, dos, etc.)')
    parser.add_argument('-t', '--timeout', type=int, default=60, help='Timeout per payload in seconds (default: 60)')
    parser.add_argument('-r', '--retry', type=int, default=0, help='Number of retries for failed payloads (default: 0)')
    parser.add_argument('--skip-recon', action='store_true', help='Skip reconnaissance phase')
    parser.add_argument('--dry-run', action='store_true', help='Show what would be executed without running')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    orchestrator = PayloadOrchestrator(
        target=args.target,
        output_file=args.output,
        severity_filter=args.severity,
        category_filter=args.category,
        timeout=args.timeout,
        retry=args.retry,
        skip_recon=args.skip_recon,
        dry_run=args.dry_run,
        verbose=args.verbose
    )
    
    success = orchestrator.run()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
